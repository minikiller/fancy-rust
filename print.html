<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust酷库推荐(Fancy Rust)</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="assets/ferris.css">
        <link rel="stylesheet" href="assets/theme/2018-edition.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> 日常开发Rust库推荐</a></li><li class="chapter-item expanded "><a href="rust-utils/index.html"><strong aria-hidden="true">2.</strong> Rust开发实用工具 todo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust-utils/macro.html"><strong aria-hidden="true">2.1.</strong> 宏 todo</a></li></ol></li><li class="chapter-item expanded "><a href="趣味Rust/intro.html"><strong aria-hidden="true">3.</strong> 有趣搞怪的项目</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="趣味Rust/turn_off_the_borrow_checker.html"><strong aria-hidden="true">3.1.</strong> 关闭你的借用检查</a></li><li class="chapter-item expanded "><a href="趣味Rust/forest-fire-model.html"><strong aria-hidden="true">3.2.</strong> 使用WASM对森林火灾进行建模</a></li></ol></li><li class="chapter-item expanded "><a href="明星项目.html"><strong aria-hidden="true">4.</strong> 明星项目</a></li><li class="chapter-item expanded "><a href="命令行工具.html"><strong aria-hidden="true">5.</strong> 命令行工具</a></li><li class="chapter-item expanded "><a href="操作系统.html"><strong aria-hidden="true">6.</strong> 操作系统</a></li><li class="chapter-item expanded "><a href="游戏.html"><strong aria-hidden="true">7.</strong> 游戏和模拟器</a></li><li class="chapter-item expanded "><a href="游戏开发.html"><strong aria-hidden="true">8.</strong> 游戏开发和图形渲染(GPU)</a></li><li class="chapter-item expanded "><a href="Javascript基础设施.html"><strong aria-hidden="true">9.</strong> Javascript和WASM</a></li><li class="chapter-item expanded "><a href="gui.html"><strong aria-hidden="true">10.</strong> GUI todo</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust酷库推荐(Fancy Rust)</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/sunface/fancy-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="fancy-rust"><a class="header" href="#fancy-rust">Fancy Rust</a></h1>
<p>在设计上，我们并没有借鉴<code>awesomes</code>常用的方式：在首页放非常长的列表,囊括一切。而是选择<strong>用户友好的方式</strong>来呈现内容:</p>
<ul>
<li><strong>主页</strong>放置用户最常用的库和资料, <strong>这里所有的库都是精心挑选和描述的</strong></li>
<li>其它优秀的库，都按照场景分类，放入<a href="https://github.com/sunface/fancy-rust"><code>src</code></a>目录下的对应<code>.md</code>文件中，例如<strong>区块链.md</strong>，<strong>游戏开发.md</strong>等</li>
<li>一般来说，同一个类别中的库按照<strong>推荐度优先级排序</strong>，越靠前，推荐度越高</li>
</ul>
<h2 id="主页目录"><a class="header" href="#主页目录">主页目录</a></h2>
<ul>
<li><a href="index.html#%E5%A4%9A%E7%BA%BF%E7%A8%8B">多线程</a> </li>
<li><a href="index.html#webhttp">Web/HTTP</a>,  <a href="index.html#SQL%E5%AE%A2%E6%88%B7%E7%AB%AF">SQL客户端</a>, <a href="index.html#NoSql%E5%AE%A2%E6%88%B7%E7%AB%AF">NoSql客户端</a>， <a href="index.html#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE">网络通信协议</a>, <a href="index.html#%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B">异步网络编程</a></li>
<li><a href="index.html#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0">服务发现</a>, <a href="index.html#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">消息队列</a>, <a href="index.html#%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E">搜索引擎</a></li>
<li><a href="index.html#%E7%BC%96%E8%A7%A3%E7%A0%81">编解码</a>, <a href="index.html#Email">Email</a>, <a href="index.html#%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E6%A8%A1%E7%89%88">常用正则模版</a></li>
<li><a href="index.html#%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7">日志监控</a>, <a href="index.html#%E4%BB%A3%E7%A0%81Debug">代码Debug</a>, <a href="index.html#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">性能优化</a></li>
</ul>
<h2 id="日常开发常用rust库"><a class="header" href="#日常开发常用rust库">日常开发常用Rust库</a></h2>
<h3 id="webhttp"><a class="header" href="#webhttp">Web/HTTP</a></h3>
<ul>
<li>
<p>HTTP客户端</p>
<ul>
<li><a href="https://github.com/seanmonstar/reqwest">reqwest</a>  一个简单又强大的HTTP客户端，<code>reqwest</code>是目前使用最多的HTTP库 </li>
</ul>
</li>
<li>
<p>Web框架</p>
<ul>
<li><a href="https://github.com/tokio-rs/axum">axum</a>  基于Tokio和Hyper打造，模块化设计较好，目前口碑很好，值得使用Ergonomic and modular web framework built with Tokio, Tower, and Hyper</li>
<li><a href="https://github.com/SergioBenitez/Rocket">Rocket</a>  功能强大，API简单的Web框架，但是主要开发者目前因为个人原因无法进行后续开发，未来存在不确定性</li>
<li><a href="https://github.com/actix/actix-web">actix-web</a>  性能极高的Web框架，就是团队内部有些问题，未来存在一定的不确定性</li>
<li>总体来说，上述三个web框架都有很深的用户基础，其实都可以选用，如果让我推荐，顺序如下: <code>axum</code> &gt; <code>Rocket</code> &gt; <code>actix-web</code>。 不过如果你不需要多么完善的web功能，只需要一个性能极高的http库，那么<code>actix-web</code>是非常好的选择，它的性能非常非常非常高！</li>
</ul>
</li>
</ul>
<h3 id="日志监控"><a class="header" href="#日志监控">日志监控</a></h3>
<ul>
<li>日志
[<a href="https://crates.io/keywords/log">crates.io</a>] [<a href="https://github.com/search?q=rust+log">github</a>]
<ul>
<li><a href="https://github.com/tokio-rs/tracing">tokio-rs/tracing</a>  强大的日志框架，同时还支持OpenTelemetry格式，无缝打通未来的监控</li>
<li><a href="https://github.com/rust-lang/log">rust-lang/log</a>  官方日志库，事实上的API标准, 但是三方库未必遵循</li>
<li><a href="https://github.com/estk/log4rs">estk/log4rs</a>  模仿JAVA <code>logback</code>和<code>log4j</code>实现的日志库, 可配置性较强</li>
<li>在其它文章中，也许会推荐slog，但是我们不推荐，一个是因为近半年未更新，一个是<code>slog</code>自己也推荐使用<code>tracing</code>。</li>
</ul>
</li>
<li>监控
<ul>
<li><a href="https://github.com/open-telemetry/opentelemetry-rust">OpenTelemetry</a>  <code>OpenTelemetry</code>是现在非常火的可观测性解决方案，提供了协议、API、SDK等核心工具，用于收集监控数据，最后将这些metrics/logs/traces数据写入到<code>prometheus</code>, <code>jaeger</code>等监控平台中。最主要是，它后台很硬，后面有各大公司作为背书，未来非常看好！</li>
<li><a href="https://github.com/vectordotdev/vector">vectordotdev/vector</a>  一个性能很高的数据采集agent，采集本地的日志、监控等数据，发送到远程的kafka、jaeger等数据下沉端，它最大的优点就是能从多种数据源(包括Opentelemetry)收集数据，然后推送到多个数据处理或者存储等下沉端。</li>
</ul>
</li>
</ul>
<h3 id="sql客户端"><a class="header" href="#sql客户端">SQL客户端</a></h3>
<ul>
<li>
<p>性能对比</p>
<ul>
<li><a href="https://github.com/diesel-rs/metrics">metrics</a> 该库对Rust现存的数据库连接服务进行性能测试，若大家有性能上的需求，值得一看</li>
</ul>
</li>
<li>
<p>通用</p>
<ul>
<li><a href="https://github.com/launchbadge/sqlx">launchbadge/sqlx</a> 异步实现、高性能、纯Rust代码的SQL库，支持<code>PostgreSQL</code>, <code>MySQL</code>, <code>SQLite</code>,和 <code>MSSQL</code>.</li>
</ul>
</li>
<li>
<p>ORM</p>
<ul>
<li><a href="https://github.com/rbatis/rbatis">rbatis/rbatis</a>  国内团队开发的ORM，异步、性能高、简单易上手</li>
<li><a href="https://github.com/diesel-rs/diesel">diesel-rs/diesel</a>  安全、扩展性强的Rust ORM库，支持<code>Mysql</code>、<code>Postgre</code>、<code>SqlLite</code></li>
</ul>
</li>
<li>
<p>Mysql</p>
<ul>
<li><a href="https://github.com/blackbeam/rust-mysql-simple">blackbeam/rust-mysql-simple</a>  纯Rust实现的Mysql驱动,提供连接池</li>
<li><a href="https://github.com/blackbeam/mysql_async">blackbeam/mysql_async</a>  基于Tokio实现的异步Mysql驱动</li>
<li>上面两个都是一个团队出品，前者文档更全、star更多，建议使用前者</li>
</ul>
</li>
<li>
<p>Postgre</p>
<ul>
<li><a href="https://github.com/sfackler/rust-postgres">sfackler/rust-postgres</a> 纯Rust实现的Postgre客户端</li>
</ul>
</li>
<li>
<p>Sqlite</p>
<ul>
<li><a href="https://github.com/rusqlite/rusqlite">rusqlite</a> 用于<a href="https://www.sqlite.org/index.html">Sqlite3</a>的Rust客户端</li>
</ul>
</li>
</ul>
<h3 id="nosql客户端"><a class="header" href="#nosql客户端">NoSql客户端</a></h3>
<ul>
<li>
<p>Redis</p>
<ul>
<li><a href="https://github.com/mitsuhiko/redis-rs">mitsuhiko/redis-rs</a> 虽然最近更新不太活跃，但是它依然是最好的redis客户端，说实话，我期待更好的，可能这也是Rust生态的未来可期之处吧</li>
</ul>
</li>
<li>
<p>Canssandra</p>
<ul>
<li><a href="https://github.com/krojew/cdrs-tokio">krojew/cdrs-tokio</a> [<a href="https://crates.io/crates/cdrs-tokio">cdrs-tokio</a>] 生产可用的Cassandra客户端，异步、纯Rust实现，就是个人项目 + star较少，未来不确定会不会不维护</li>
<li><a href="https://github.com/scylladb/scylla-rust-driver">scylla-rust-driver</a>  ScyllaDB提供的官方库，支持cql协议，由于背靠大山，未来非常可期</li>
</ul>
</li>
<li>
<p>MongoDB</p>
<ul>
<li><a href="https://github.com/mongodb/mongo-rust-driver">mongodb/mongo-rust-driver</a> 官方MongoDB客户端，闭着眼睛选就对了</li>
</ul>
</li>
</ul>
<h3 id="分布式"><a class="header" href="#分布式">分布式</a></h3>
<h4 id="服务发现"><a class="header" href="#服务发现">服务发现</a></h4>
<ul>
<li><a href="https://github.com/luncj/etcd-rs">luncj/etcd-rs</a> 异步实现的Rust etcd客户端，优点是有一定的文档、作者较为活跃,意味着你提问题他可能会回答，不过，如果你不放心，还是考虑使用HTTP的方式访问ETCD</li>
</ul>
<h4 id="消息队列"><a class="header" href="#消息队列">消息队列</a></h4>
<ul>
<li>Kafka
<ul>
<li><a href="https://github.com/fede1024/rust-rdkafka">fede1024/rust-rdkafka</a>  Rust Kafka客户端，基于C版本的Kafka库[librdkafka]实现，文档较全、功能较为全面</li>
<li><a href="https://github.com/kafka-rust/kafka-rust">kafka-rust/kafka-rust</a>  相比上一个库，它算是纯Rust实现，文档还行，支持Kafka0.8.2及以后的版本，但是对于部分0.9版本的特性还不支持。同时有一个问题：最初的作者不维护了，转给了现在的作者，但是感觉好像也不是很活跃</li>
</ul>
</li>
<li>Nats
<ul>
<li><a href="https://github.com/nats-io/nats.rs">nats-io/nats.rs</a> Nats官方提供的客户端</li>
</ul>
</li>
</ul>
<h3 id="网络通信协议"><a class="header" href="#网络通信协议">网络、通信协议</a></h3>
<ul>
<li>Websocket
<ul>
<li><a href="https://github.com/snapview/tokio-tungstenite">snapview/tokio-tungstenite</a> 更适合Web应用使用的生产级Websocket库，它是异步非阻塞的，基于基于下下面的<code>tungstenite-rs</code>库和tokio实现</li>
<li><a href="https://github.com/websockets-rs/rust-websocket">rust-websocket</a>  老牌Websocket库，提供了客户端和服务器端实现，但是。。。很久没更新了</li>
<li><a href="https://github.com/snapview/tungstenite-rs">snapview/tungstenite-rs</a> 轻量级的Websocket流实现，该库更偏底层，例如，你可以用来构建其它网络库</li>
</ul>
</li>
<li>gRPC
<ul>
<li><a href="https://github.com/hyperium/tonic">hyperium/tonic</a> 纯Rust实现的gRPC客户端和服务器端，支持async/await异步调用，文档和示例较为清晰</li>
<li><a href="https://github.com/tikv/grpc-rs">tikv/grpc-rs</a> 国产开源之光Tidb团队出品的gRPC框架, 基于C的代码实现, 就是最近好像不是很活跃</li>
<li>其实这两个实现都很优秀，把<code>tonic</code>放在第一位，主要是因为它是纯Rust实现，同时社区也更为活跃，但是并不代表它比<code>tikv</code>的更好！</li>
</ul>
</li>
<li>QUIC
<ul>
<li><a href="https://github.com/cloudflare/quiche">cloudflare/quiche</a> 大名鼎鼎<code>cloudflare</code>提供的QUIC实现，据说在公司内部重度使用，有了大规模生产级别的验证，非常值得信任，同时该库还实现了HTTP/3</li>
<li><a href="https://github.com/quinn-rs/quinn">quinn-rs/quinn</a> 提供异步API调用，纯Rust实现，同时提供了几个有用的网络库</li>
</ul>
</li>
<li>MQTT
<ul>
<li><a href="https://github.com/bytebeamio/rumqtt">bytebeamio/rumqtt</a>  MQTT3.1.1/5协议库，同时实现了客户端与服务器端broker</li>
<li><a href="https://github.com/ntex-rs/ntex-mqtt">ntex-rs/ntex-mqtt</a>  客户端与服务端框架，支持MQTT3.1.1与5协议</li>
<li><a href="https://github.com/eclipse/paho.mqtt.rust">eclipse/paho.mqtt.rust</a>  老牌MQTT框架，对MQTT支持较全, 其它各语言的实现也有</li>
</ul>
</li>
</ul>
<h3 id="异步网络编程"><a class="header" href="#异步网络编程">异步网络编程</a></h3>
<ul>
<li><a href="https://github.com/tokio-rs/tokio">tokio-rs/tokio</a> 最火的异步网络库，除了复杂上手难度高一些外，没有其它大的问题。同时tokio团队提供了多个非常优秀的Rust库，整个生态欣欣向荣，用户认可度很高</li>
<li><a href="https://async.rs/">async-std</a> 跟标准库API很像的异步网络库，相对简单易用，但是貌似开发有些停滞，还有就是功能上不够完善。但是对于普通用户来说，这个库非常值得一试，它在功能和简单易用上取得了很好的平衡</li>
<li><a href="https://github.com/actix/actix">actix</a> 基于Actor模型的异步网络库，但这个库的开发貌似已经停滞，他们团队一直在专注于<code>actix-web</code>的开发</li>
<li><a href="https://github.com/tokio-rs/mio">mio</a> 严格来说，MIO与之前三个不是同一个用途的，MIO = Meta IO，是一个底层IO库，往往用于构建其它网络库，当然如果你对应用网络性能有非常极限的要求， 可以考虑它，因为它的层次比较低，所带来的抽象负担小，所以性能损耗小</li>
<li>如果你要开发生产级别的项目，我推荐使用<code>tokio</code>，稳定可靠，功能丰富，控制粒度细；自己的学习项目或者没有那么严肃的开源项目，我推荐<code>async-std</code>，简单好用，值得学习；当你确切知道需要Actor网络模型时，就用<code>actix</code></li>
</ul>
<h3 id="搜索引擎"><a class="header" href="#搜索引擎">搜索引擎</a></h3>
<ul>
<li>
<p>ElasticSearch客户端</p>
<ul>
<li><a href="https://github.com/elastic/elasticsearch-rs">elastic/elasticsearch</a> 官方es客户端，目前第三方的基本都处于停滞状态，所以不管好坏，用呗</li>
</ul>
</li>
<li>
<p>Rust搜索引擎</p>
<ul>
<li><a href="https://github.com/quickwit-inc/tantivy">Tantivy</a> Tantivy是Rust实现的本地搜索库，功能对标<code>lucene</code>，如果你不需要分布式，那么引入tantivy作为自己本地Rust服务的一个搜索，是相当不错的选择，该库作者一直很活跃，而且最近还创立了搜索引擎公司，感觉大有作为. 该库的优点在于纯Rust实现，性能高(lucene的2-3倍)，资源占用低(对比java自然不是一个数量级)，社区活跃。</li>
</ul>
</li>
<li>
<p>Rust搜索平台</p>
<ul>
<li><a href="https://github.com/quickwit-inc/quickwit">quickwit</a> 对标ElasticSearch，一个通用目的的分布式搜索平台，目前还在起步阶段(0.2版本)，未来非常可期，目前还不建议使用</li>
<li><a href="https://github.com/meilisearch/MeiliSearch">MeiliSearch</a> 虽然也是一个搜索平台，但是并不是通用目的的，<code>MeiliSearch</code>目标是为终端用户提供边输入边提示的即刻搜索功能，因此是一个轻量级搜索平台，不适用于数据量大时的搜索目的。总之，如果你需要在网页端或者APP为用户提供一个搜索条，然后支持输入容错、前缀搜索时，就可以使用它。</li>
<li></li>
</ul>
</li>
</ul>
<h3 id="代码debug"><a class="header" href="#代码debug">代码Debug</a></h3>
<ul>
<li>GDB
<ul>
<li><a href="https://github.com/cs01/gdbgui">gdbgui</a>  提供浏览器支持的gdb debug工具，支持C，C++，Rust和Go.</li>
</ul>
</li>
<li>LLDB
<ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb">CodeLLDB</a> — 专门为VSCode设计的LLDB Debug扩展</li>
</ul>
</li>
</ul>
<h3 id="性能优化"><a class="header" href="#性能优化">性能优化</a></h3>
<ul>
<li><a href="https://github.com/bheisler/criterion.rs">bheisler/criterion.rs</a> 比官方提供的benchmark库更好，目前已经成为事实上标准的性能测试工具</li>
<li><a href="https://github.com/koute/bytehound">Bytehound</a> Linux下的内存分析工具，可以用来分析：内存泄漏、内存分配、调用栈追踪，甚至它还有一个浏览器UI! 懂的人都懂，性能测试工具的UI服务是多么稀缺和珍贵！</li>
<li><a href="https://github.com/llogiq/flame">llogiq/flame</a> 专为Rust打造的火焰图分析工具，可以告诉你程序在哪些代码上花费的时间过多，非常适合用于代码性能瓶颈的分析。与<code>perf</code>不同，<code>flame</code>库允许你自己定义想要测试的代码片段，只需要在代码前后加上相应的指令即可，非常好用</li>
<li><a href="https://github.com/sharkdp/hyperfine">sharkdp/hyperfine</a> 一个命令行benchmark工具，支持任意shell命令，支持缓存清除、预热、多次运行统计分析等，尽量保证结果的准确性</li>
</ul>
<h3 id="多线程"><a class="header" href="#多线程">多线程</a></h3>
<ul>
<li>消息通道channel
<ul>
<li><a href="https://github.com/crossbeam-rs/crossbeam/tree/master/crossbeam-channel"><strong>crossbeam-channel</strong></a>, 老牌强库，功能较全，性能较强，之前是独立的库，但是后面合并到了<code>crossbeam</code>主仓库中</li>
<li><a href="https://github.com/zesterer/flume"><strong>flume</strong></a>, 官方给出的性能数据要比crossbeam更好些，但是貌似最近没怎么更新</li>
</ul>
</li>
<li>并发原语(锁)
<ul>
<li><a href="https://crates.io/crates/parking_lot">parking_lot</a>, 社区较为活跃，star较多，更新较为活跃</li>
<li><a href="https://crates.io/crates/spin">spin</a>, 在多数场景中性能比<code>parking_lot</code>高一点，最近没怎么更新</li>
<li>如果不是追求特别极致的性能，建议选择前者</li>
</ul>
</li>
</ul>
<h3 id="编解码"><a class="header" href="#编解码">编解码</a></h3>
<ul>
<li><a href="https://github.com/serde-rs/serde">Serde</a> 一个超高性能的通用序列化/反序列化框架，可以跟多种协议的库联合使用，实现统一编解码格式</li>
<li>CSV
<ul>
<li><a href="https://github.com/BurntSushi/rust-csv">BurntSushi/rust-csv</a> 高性能CSV读写库，支持<a href="https://github.com/serde-rs/serde">Serde</a></li>
</ul>
</li>
<li>JSON
<ul>
<li><a href="https://github.com/serde-rs/json">serde-rs/json</a> 快到上天的JSON库，也是Rust事实上的标准JSON库，你也可以使用它的大哥<a href="https://github.com/serde-rs/serde">serde</a>，一个更通用的序列化/反序列化库</li>
</ul>
</li>
<li>MsgPack
<ul>
<li><a href="https://github.com/3Hren/msgpack-rust">3Hren/msgpack-rust</a> 纯Rust实现的MessagePack编解码协议</li>
</ul>
</li>
<li>ProtocolBuffers
<ul>
<li><a href="https://github.com/tokio-rs/prost">tokio-rs/prost</a> tokio出品，基本都属精品，此库也不例外，简单易用，文档详细</li>
<li><a href="https://github.com/stepancheg/rust-protobuf">stepancheg/rust-protobuf</a> 纯Rust实现</li>
</ul>
</li>
<li>TOML
<ul>
<li><a href="https://github.com/alexcrichton/toml-rs">alexcrichton/toml-rs</a> TOML编码/解码，可以配合<code>serde</code>使用</li>
</ul>
</li>
<li>XML
<ul>
<li><a href="https://github.com/tafia/quick-xml">tafia/quick-xml</a> 高性能XML库，可以配合<code>serde</code>使用，文档较为详细</li>
</ul>
</li>
<li>YAML
<ul>
<li><a href="https://github.com/dtolnay/serde-yaml">dtolnay/serde-yaml</a> 使用<code>serde</code>编解码<code>YAML</code>格式的数据</li>
</ul>
</li>
</ul>
<h3 id="email"><a class="header" href="#email">Email</a></h3>
<ul>
<li><a href="https://github.com/lettre/lettre">lettre/lettre</a> — Rust SMTP库</li>
</ul>
<h3 id="常用正则模版"><a class="header" href="#常用正则模版">常用正则模版</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust实用工具"><a class="header" href="#rust实用工具">Rust实用工具</a></h1>
<p>Rust 社区为我们提供了很多实用的开发工具，例如宏、Debug等等。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="宏"><a class="header" href="#宏">宏</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="非常有趣的项目"><a class="header" href="#非常有趣的项目">非常有趣的项目</a></h1>
<p>在此目录中，藏有一些非常有趣但是可能用处不大的项目，例如 <code>turn_off_the_borrow_checker</code> 是一个可以关掉 Rust 编译检查的宏，如果想做坏事，你可以尝试下：）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="关掉你的编译检查"><a class="header" href="#关掉你的编译检查">关掉你的编译检查</a></h1>
<p>Rust的项目一向都是比较严肃的，虽不至于讲大道理，但是总归与有趣关系不大。但是这两天出现了一个搅局者，一起来看看。</p>
<p>该项目的名字很直白 <a href="https://github.com/jeremyBanks/you-can"><code>turn_off_the_borrow_checker</code></a> ，作用也很直接：通过引入一个宏关掉Rust的编译检查，哦呦，那是不是意味着以后再也没有人对着咱的代码指手画脚了？结论会在文末给出，先来看个例子。</p>
<h2 id="一个绕过编译检查的例子"><a class="header" href="#一个绕过编译检查的例子">一个绕过编译检查的例子</a></h2>
<pre><pre class="playground"><code class="language-rust">#[you_can::turn_off_the_borrow_checker]
fn main() {
    let mut source = 1;
    let mutable_alias = &amp;mut source;
    source = 2; // 这里本该报错，但是引入宏后，不再会报错
    *mutable_alias = 3;
    println!(&quot;{source}&quot;);
}
</code></pre></pre>
<p><code>&amp;%$#.*</code>，我的大脑一片混乱，这到底是如何做到的？宏还可以影响编译行为？闻所未闻啊，好在官方文档给出了解释。</p>
<h2 id="原理解释"><a class="header" href="#原理解释">原理解释</a></h2>
<p><code>turn_off_the_borrow_checker</code> 宏会在你的代码中寻找通过 <code>&amp;</code> 、<code>&amp;mut</code> 或 <code>ref</code>、<code>ref mut</code> 创建的引用，然后通过 <a href="https://docs.rs/unbounded/0.0.2022/unbounded/fn.reference.html"><code>::unbounded::reference()</code></a> 将其包裹起来，以实现<a href="https://course.rs/advance/lifetime/advance.html#%E6%97%A0%E7%95%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">无界生命周期</a>的效果.</p>
<p>这样编译器就会无视这些小透明，效果如同以下代码：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut source = 1;
    let mutable_alias = ::unbounded::reference(&amp;mut source);
    source = 2;
    *mutable_alias = 3;
    println!(&quot;{source}&quot;);
}
</code></pre></pre>
<h2 id="局限性"><a class="header" href="#局限性">局限性</a></h2>
<p>如果这个宏能可选的绕过我们在某些时候不希望有的编译检查就好了，可惜世事总是不遂人意。 它不是万能的，它无法消除由非法代码创建的生命周期或隐式创建的引用而导致的错误。</p>
<p>有时你可以通过引入前缀 <code>&amp;*</code> 来强制一个引用成为显式的，这在某种程度上可以解决上述的局限性：</p>
<pre><pre class="playground"><code class="language-rust">#[you_can::turn_off_the_borrow_checker]
fn main() {
    let mut source = Some(1);
    let inner_mut = &amp;*source.as_ref().unwrap();
    let mutable_alias = &amp;mut source;

    source = None;
    *mutable_alias = Some(2);

    if let Some(ref mut inner_a) = source {
        match source {
            Some(ref mut inner_b) =&gt; {
                *inner_b = inner_mut + 1;
                *inner_a = inner_mut + 2;
            },
            None =&gt; {
                println!(&quot;none&quot;);
            },
        }
    }

    println!(&quot;{source:?}&quot;);
}
</code></pre></pre>
<p>以上代码使用宏后展开如下:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut source = Some(1);
    let inner_mut = ::unbounded::reference(&amp;*source.as_ref().unwrap());
    let mutable_alias = ::unbounded::reference(&amp;mut source);

    source = None;
    *mutable_alias = Some(2);

    if let Some(ref mut inner_a) = source {
        let inner_a = ::unbounded::reference(inner_a);

        match source {
            Some(ref mut inner_b) =&gt; {
                let inner_b = ::unbounded::reference(inner_b);

                *inner_b = inner_mut + 1;
                *inner_a = inner_mut + 2;
            },
            None =&gt; {
                println!(&quot;none&quot;);
            },
        }
    }

    println!(&quot;{source:?}&quot;);
}
</code></pre></pre>
<h2 id="使用场景"><a class="header" href="#使用场景">使用场景</a></h2>
<p>其实这篇文章是 <a href="https://fancy.rs">Fancy Rust</a> 的其中一篇，所属的目录是<strong>有趣的 Rust 项目</strong>，从这里大概就能猜出我们完全不推荐在生产环境使用该项目。</p>
<p>作者也是这个态度：此项目仅适用于教学或耍帅的目的，如果要在生产使用，那勇士，你走好：）</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="使用-wsam-对森林火灾进行建模"><a class="header" href="#使用-wsam-对森林火灾进行建模">使用 WSAM 对森林火灾进行建模</a></h2>
<p>偶然在 github 上发现一个非常有趣的项目，该项目使用 Rust + WASM 对森林火灾的发生过程进行了建模，非常适合学习。 有趣的是，该项目甚至没有使用 GPU shader，只用 CPU 就达到了如此丝滑的表现。</p>
<blockquote>
<p>小提示：最好运行1-2分钟，会出现有趣的现象。 使用空格键可以打开控制面板，还可以长按鼠标左键拖动以制造火焰</p>
</blockquote>
<ul>
<li>项目地址：https://github.com/Gerstacker/macroquad-forestfire</li>
<li>演示地址: https://gerstacker.github.io/macroquad-forestfire/</li>
</ul>
<img src="https://pic4.zhimg.com/80/v2-20eaf16caa2ec02651b4912d93a75dab_1440w.jpg" /><div style="break-before: page; page-break-before: always;"></div><h1 id="明星项目"><a class="header" href="#明星项目">明星项目</a></h1>
<blockquote>
<p>滚滚长江东逝水，浪花淘尽英雄，是非成败转头空 - 临江仙·滚滚长江东逝水</p>
</blockquote>
<p>经过大浪淘沙留下来的才是真金白银，对于开源项目也是如此。对于明星项目，本文不仅仅以<code>star</code>数的多少作为评判维度，还会结合项目规模、影响力、活跃度、社区活跃度等多个方面进行评定，希望大家能喜欢。</p>
<p>需要注意，本文列出的几乎都是平台级项目，因此并不是star多，就能名列其中，例如很多<code>star</code>很多的工具、Rust库、书籍都没有列入，如果大家想要看更多的子类项目，请访问对应的文件进行查看。</p>
<h2 id="deno"><a class="header" href="#deno">deno</a></h2>
<p>首先出场的自然是咖位最重的之一，可以说正是因为<code>deno</code>和<code>swc</code>的横空出世，才让一堆观望的大神对于Rust实现<code>Javascript</code>基建有了更强的信心。</p>
<p><a href="https://github.com/topics/rust?l=rust&amp;o=desc&amp;s=stars"><code>deno</code></a>是<code>node</code>半逆转后的字序，从此可以看出<code>deno</code>是<code>Node.js</code>的替代，它的目标是为<code>Typescript/Javascript</code>提供一个更现代化、更安全、更强大    的运行时，同时内置了很多强大的工具，可以用于打包、编译成可执行文件、文档、测试、lint等。</p>
<h2 id="alacritty"><a class="header" href="#alacritty">alacritty</a></h2>
<p><a href="https://github.com/alacritty/alacritty">alacritty</a>是一个跨平台、基于OpenGL的终端，性能极高的同时还支持丰富的自定义和可扩展性，可以说是非常优秀的现代化终端。</p>
<p>目前已经是<code>beta</code>阶段，可以作为日常工具来使用。</p>
<img alt="alacritty screenshot" width="100%" src="./img/superstar/alacritty.png" class="center"  />
<h2 id="starship"><a class="header" href="#starship">starship</a></h2>
<p><a href="https://github.com/starship/starship">starship</a>是一个命令行提示，支持任何<code>shell</code>，包括<code>zsh</code>，简单易用、非常快且拥有极高的可配置性, 同时支持智能提示。</p>
<img alt="starship screenshot" width="100%"  src="https://raw.githubusercontent.com/starship/starship/master/media/demo.gif" class="center"  />
<h2 id="meilisearch"><a class="header" href="#meilisearch">MeiliSearch</a></h2>
<p><a href="https://github.com/meilisearch/MeiliSearch">MeiliSearch</a>是一个搜索平台，但是跟<code>ElasticSearch</code>不同，<code>MeiliSearch</code>并不是通用目的的，它的目标是为终端用户提供边输入边提示的即刻搜索功能，因此是一个轻量级搜索平台，不适用于数据量大时的搜索目的。</p>
<p>总之，如果你需要在网页端或者APP为用户提供一个搜索条，然后支持输入容错、前缀搜索时，就可以使用它。</p>
<img alt="meilisearch screenshot" width="100%" src="./img/superstar/meilisearch.gif" class="center"  />
<h2 id="swc-195k"><a class="header" href="#swc-195k">swc 🌟19.5k</a></h2>
<p><a href="https://github.com/swc-project/swc"><code>swc</code></a>是<code>Typescript/Javascript</code>编译器，它可以用来编译、压缩和打包JS，同时支持使用插件进行扩展，例如做代码变换等。</p>
<p><code>swc</code>目前正在被一些知名项目所使用，包括<code>Next.js</code>,<code>Parcel</code>和<code>Deno</code>，还有些著名的公司也在使用它，例如<code>Vercel</code>、字节跳动、腾讯等。</p>
<p>它的性能非常非常高，官方号称，在单线程下比<code>Babel</code>快20倍，在4核心下比<code>Babel</code>快70倍！</p>
<p>几个使用案例：</p>
<ul>
<li><a href="http://nextjs.org/12">nextjs 12</a>, 通过使用<code>swc</code>获得了更好的扩展性、性能以及wasm的支持，其中性能方面提升了3倍刷新速度、5倍打包速度</li>
<li><a href="https://parceljs.org/">Parcel</a>，通过使用<code>swc</code>改善了10倍的性能</li>
</ul>
<img alt="parcel screenshot" width="100%" src="./img/javascript/parcel.png" class="center"  />
<h2 id="tauri"><a class="header" href="#tauri">tauri</a></h2>
<p><a href="https://tauri.studio">tauri</a>可以用来更小、更快、更安全的桌面应用，它想要替代的是<code>electro.js</code>。</p>
<p>下面是援引自<a href="https://tauri.studio/benchmarks">官网</a>的性能对比图:</p>
<img alt="tauri1 screenshot" width="100%" src="./img/superstar/tauri1.png" class="center"  />
<img alt="tauri2 screenshot" width="100%" src="./img/superstar/tauri2.png" class="center"  />
<h2 id="yew"><a class="header" href="#yew">yew</a></h2>
<p><a href="https://github.com/yewstack/yew"><code>yew</code></a>是一个正在活跃开发的<code>Rust/Wasm</code>框架，用于构建<code>Web</code>应用。</p>
<img alt="yew screenshot" width="100%" src="./img/javascript/yew.jpg" class="center"  />
<h2 id="firecracker"><a class="header" href="#firecracker">firecracker</a></h2>
<p><a href="https://github.com/firecracker-microvm/firecracker"><code>firecracker</code></a>是一个安全、高性能的无服务计算虚拟机(FaaS)，支持多租户、资源隔离等高级特性，由Amazon公司开发，为AWS部分云计算服务提供了强力有的支持。BTW，亚马逊Amazon公司对于Rust语言的喜爱是众所周知的，几乎已经成了Rust的形象大使之一了:）</p>
<h2 id="nushell"><a class="header" href="#nushell">nushell</a></h2>
<p><a href="https://github.com/nushell/nushell"><code>nushell</code></a>是一个全新的<code>shell</code>，使用<code>Rust</code>实现。它的目标是创建一个现代化的<code>shell</code>：虽然依然基于<code>Unix</code>的哲学，但是更适合现在的时代。例如，你可以使用<code>SQL</code>语法来选择你想要的内容！</p>
<img alt="delta screenshot" width="100%"  src="https://github.com/nushell/nushell/raw/main/images/nushell-autocomplete5.gif" class="center"  />
<h2 id="tokio"><a class="header" href="#tokio">tokio</a></h2>
<p><a href="https://github.com/tokio-rs/tokio"><code>tokio</code></a>的名声可以说是如雷贯耳，如果学过Rust但是没有听说过它，那我觉得可能要回炉重造下:)</p>
<p><code>tokio</code>是一个异步IO的运行时，提供了<code>I/O</code>、网络、调度、定时器等等异步编程所必须的功能和工具，性能和功能都异常强大。</p>
<h2 id="appflowy"><a class="header" href="#appflowy">AppFlowy</a></h2>
<p><a href="https://github.com/AppFlowy-IO/appflowy">AppFlowy</a>是<a href="https://www.notion.so/zh-cn"><code>Notion</code></a>的开源实现，使用<code>Rust</code>和<code>Flutter</code>进行开发，用于用户文档和数据的管理，支持丰富的自定义特性。</p>
<img alt="appflowy screenshot" width="100%" src="./img/superstar/appflowy.png" class="center"  />
<h2 id="bevy"><a class="header" href="#bevy">Bevy</a></h2>
<p><a href="https://github.com/bevyengine/bevy">bevy</a>是一个数据驱动的游戏引擎，支持2D和3D图形开发，优点是社区活跃、更新快、模块化设计优秀、性能高，缺点是还处于快速开发中，并不适合生产使用。</p>
<p>同时<code>bevy</code>的文档齐全，官方示例很多，非常适合学习和使用。</p>
<img alt="bevy screenshot" width="100%" src="./img/gamedev/bevy.jpg" class="center"  />
<h2 id="actix-web"><a class="header" href="#actix-web">actix-web</a></h2>
<p><a href="">actix-web</a>是全世界最快的web框架之一，甚至可以把之一去掉，因为排在它前面的看上去像是一个专为跑分而生的轻量级框架，而<code>actix-web</code>可是功能相当多的！</p>
<p>下面给出<code>actix</code>和Go语言<code>Gin</code>框架的性能对比：</p>
<img alt="actix screenshot" width="100%" src="./img/superstar/actix.png" class="center"  />
<h2 id="iced"><a class="header" href="#iced">iced</a></h2>
<p><a href="https://github.com/iced-rs/iced"><code>iced</code></a>是一个跨平台GUI库，具有简单易用、模块化设计、响应式布局等优点。</p>
<img alt="iced screenshot" width="100%" src="./img/superstar/iced.gif" class="center"  />
<h2 id="cubejs"><a class="header" href="#cubejs">cube.js</a></h2>
<p><a href="https://github.com/cube-js/cube.js"><code>cube.js</code></a>是一个数据分析API平台，可以用于构建内部的BI或为现有的应用增加客户数据统计等功能，使用<code>Rust</code>和<code>Typescript</code>构建。</p>
<img alt="cubejs screenshot" width="100%" src="./img/superstar/cubejs.png" class="center"  />
<h2 id="wasmer"><a class="header" href="#wasmer">wasmer</a></h2>
<p><a href="https://github.com/wasmerio/wasmer">wasmer</a>是业界领先的<code>WASM</code>运行时，支持<code>WASI</code>和<code>Emscripten</code>。</p>
<pre><code class="language-shell">$ wasmer qjs.wasm
QuickJS - Type &quot;\h&quot; for help
qjs &gt; const i = 1 + 2;
qjs &gt; console.log(&quot;hello &quot; + i);
hello 3
</code></pre>
<h2 id="tikv"><a class="header" href="#tikv">tikv</a></h2>
<p><a href="https://github.com/tikv/tikv"><code>tikv</code></a>相信大家都已知道，<code>tidb</code>的底层存储服务，国人之光项目，在数据之外，还做了大量的技术知识普及工作，值得敬佩！</p>
<p><code>tikv</code>是分布式<code>KV</code>数据库，支持分布式事务。</p>
<img alt="tikv screenshot" width="100%" src="./img/superstar/tikv.png" class="center"  />
<h2 id="ruffle"><a class="header" href="#ruffle">ruffle</a></h2>
<p><a href="https://github.com/ruffle-rs/ruffle"><code>ruffle</code></a>是用Rust写的<code>Flash Player</code>模拟器，同时支持桌面端和Web端，其中后者通过WASM提供支持。</p>
<h2 id="rustdesk"><a class="header" href="#rustdesk">rustdesk</a></h2>
<p><a href="https://github.com/rustdesk/rustdesk"><code>rustdesk</code></a>是国内团队开发的一款远程桌面软件。</p>
<img alt="rustdesk screenshot" width="100%" src="./img/superstar/rustdesk.jpg" class="center"  />
<h2 id="rustpython"><a class="header" href="#rustpython">RustPython</a></h2>
<p>[<code>RustPython</code>]是使用<code>Rust</code>实现的<code>Python</code>解释器, 支持<code>Python3</code>（CPython &gt;= 3.9.0）。</p>
<p>大家可以通过官方提供的<a href="https://rustpython.github.io/demo/">在线网址</a>进行尝试。</p>
<img alt="rustpython screenshot" width="100%" src="./img/superstar/rustpython.jpg" class="center"  />
<h2 id="vector"><a class="header" href="#vector">vector</a></h2>
<p><a href="https://github.com/vectordotdev/vector"><code>vector</code></a>是一个性能很高的数据采集agent，采集本地的日志、监控等数据，发送到远程的kafka、jaeger等数据下沉端，它最大的优点就是能从多种数据源(包括Opentelemetry)收集数据，然后推送到多个数据处理或者存储等下沉端。</p>
<img alt="vector screenshot" width="100%" src="./img/superstar/vector.jpg" class="center"  />
<h2 id="mdbook"><a class="header" href="#mdbook">mdbook</a></h2>
<p><a href="https://github.com/rust-lang/mdBook"><code>mdbbok</code></a>可以基于<code>markdown</code>文件自动创建在线电子书，非常简单好用，目前的问题就是缺乏章节内部的目录跳转和中文搜索。</p>
<img alt="mdbook screenshot" width="100%" src="./img/superstar/mdbook.jpg" class="center"  />
<h2 id="zola"><a class="header" href="#zola">zola</a></h2>
<p><a href="https://github.com/getzola/zola"><code>zola</code></a>是一个静态网站生成器，类似<code>hugo</code>。</p>
<img alt="zola screenshot" width="100%" src="./img/superstar/zola.jpg" class="center"  />
<h2 id="gitui"><a class="header" href="#gitui">gitui</a></h2>
<p><a href="https://github.com/extrawurst/gitui"><code>gitui</code></a>是一个奇快无比的Git终端UI，无需浏览器即可使用。</p>
<img alt="gitui screenshot" width="100%" src="./img/superstar/gitui.gif" class="center"  />
<h2 id="solana"><a class="header" href="#solana">solana</a></h2>
<p><a href="https://github.com/solana-labs/solana"><code>solana</code></a>是知名的区块链平台，快速、安全、去中心化，还自带应用市场。</p>
<h2 id="ripgrep"><a class="header" href="#ripgrep">ripgrep</a></h2>
<p><a href="https://github.com/BurntSushi/ripgrep"><code>ripgrep</code></a>是一个性能极高的现代化<code>grep</code>实现，后者是<code>Unix/Linux</code>下的内置文件搜索工具。该项目是Rust的明星项目，一个是因为性能极其的高，另一个就是源代码质量很高，值得学习, 同时<code>Vscode</code>使用它作为内置的搜索引擎。</p>
<p>从功能来说，除了全面支持<code>grep</code>的功能外，<code>repgre</code>支持使用正则递归搜索指定的文件目录，默认使用<code>.gitignore</code>对指定的文件进行忽略。</p>
<img alt="ripgrep screenshot" width="100%"  src="./img/command-line/ripgrep.png" class="center"  />
<h2 id="citybound"><a class="header" href="#citybound">citybound</a></h2>
<p><a href="https://github.com/citybound/citybound"><code>citybound</code></a>是一个多人在线模拟游戏，使用Rust + WASM + JS开发。</p>
<img alt="citybound screenshot" width="100%" src="./img/game/citybound.png" class="center"  />
<h2 id="bottlerocket"><a class="header" href="#bottlerocket">bottlerocket</a></h2>
<p><a href="https://github.com/bottlerocket-os/bottlerocket"><code>bottlerocket</code></a>是一个基于<code>Linux</code>的操作系统，它的目标是为容器提供宿主环境。</p>
<h2 id="lemmy"><a class="header" href="#lemmy">lemmy</a></h2>
<p><a href="https://github.com/LemmyNet/lemmy"><code>lemmy</code></a>是一个<code>reddit</code>克隆，可以通过连接聚合的方式来构建社区，支持桌面和移动端。</p>
<img alt="lemmy screenshot" width="100%" src="./img/superstar/lemmy.jpg" class="center"  />
<h2 id="tantivy"><a class="header" href="#tantivy">tantivy</a></h2>
<p><a href="https://github.com/quickwit-inc/tantivy"><code>tantivy</code></a>是Rust实现的本地搜索库，功能对标<code>lucene</code>，如果你不需要分布式，那么引入tantivy作为自己本地Rust服务的一个搜索，是相当不错的选择，该库作者一直很活跃，而且最近还创立了搜索引擎公司，感觉大有作为. 该库的优点在于纯Rust实现，性能高(lucene的2-3倍)，资源占用低(对比java自然不是一个数量级)，社区活跃。</p>
<h2 id="sled"><a class="header" href="#sled">sled</a></h2>
<p><a href="https://github.com/spacejam/sled"><code>sled</code></a>是本地嵌入式的数据库。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tree = sled::open(&quot;/tmp/welcome-to-sled&quot;)?;

// insert and get, similar to std's BTreeMap
let old_value = tree.insert(&quot;key&quot;, &quot;value&quot;)?;

assert_eq!(
  tree.get(&amp;&quot;key&quot;)?,
  Some(sled::IVec::from(&quot;value&quot;)),
);

// range queries
for kv_result in tree.range(&quot;key_1&quot;..&quot;key_9&quot;) {}

// deletion
let old_value = tree.remove(&amp;&quot;key&quot;)?;

// atomic compare and swap
tree.compare_and_swap(
  &quot;key&quot;,
  Some(&quot;current_value&quot;),
  Some(&quot;new_value&quot;),
)?;

// block until all operations are stable on disk
// (flush_async also available to get a Future)
tree.flush()?;
<span class="boring">}
</span></code></pre></pre>
<h3 id="redox"><a class="header" href="#redox">redox</a></h3>
<p><a href="https://github.com/redox-os/redox"><code>Redox</code></a>是一个<code>Unix</code>风格的微内核操作系统，使用<code>Rust</code>实现。<code>redox</code>的目标是安全、快速、免费、可用，它在内核设计上借鉴了很多优秀的内核，例如：<code>SeL4</code>, <code>MINIX</code>, <code>Plan 9</code>和<code>BSD</code>。</p>
<p>但<code>redox</code>不仅仅是一个内核，它还是一个功能齐全的操作系统，提供了操作系统该有的功能，例如：内存分配器、文件系统、显示管理、核心工具等等。你可以大概认为它是一个<code>GNU</code>或<code>BSD</code>生态，但是是通过一门现代化、内存安全的语言实现的。</p>
<blockquote>
<p>不过据我仔细观察，redox目前的开发进度不是很活跃，不知道发生了什么，未来若有新的发现会在这里进行更新 - Sunface</p>
</blockquote>
<img alt="redox1 screenshot" width="100%" src="./img/os/redox1.jpg" class="center"  />
<img alt="redox2 screenshot" width="100%" src="./img/os/redox2.jpeg" class="center"  />
<h3 id="youki"><a class="header" href="#youki">youki</a></h3>
<p><a href="https://github.com/containers/youki"><code>youki</code></a>是一个容器运行时，实现了<code>OCI</code>标准，性能非常好的同时具备非常高的安全性, 目前来说，它的性能跟<code>crun</code>差不多，比<code>runc</code>快50%以上。</p>
<h3 id="sixtyfps"><a class="header" href="#sixtyfps">sixtyfps</a></h3>
<p><a href="https://github.com/sixtyfpsui/sixtyfps"><code>sixtyfps</code></a>是一个GUI工具集，同时适用于嵌入式系统、桌面系统、移动端、浏览器(WASM)，支持使用多种语言进行开发，背后有商业公司的支持，未来前景看好。</p>
<img alt="sixtyfps screenshot" width="100%" src="./img/superstar/sixtyfps.png" class="center"  />
<h3 id="wasmtime"><a class="header" href="#wasmtime">wasmtime</a></h3>
<p><a href="https://github.com/bytecodealliance/wasmtime">wasmtime</a>是一个为<code>WASM</code>设计的<code>JIT</code>风格的独立运行时，支持<code>WASI</code>。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<pre><code class="language-shell">$ rustup target add wasm32-wasi
$ rustc hello.rs --target wasm32-wasi
$ wasmtime hello.wasm
Hello, w
</code></pre>
<h3 id="polkadot"><a class="header" href="#polkadot">polkadot</a></h3>
<p><a href="https://github.com/paritytech/polkadot"><code>polkadot</code></a>是知名的区块链平台，它是从<a href="https://github.com/paritytech/substrate"><code>Substrate</code></a>抽离出来，后者是下一代区块链开发框架。</p>
<h3 id="lapce"><a class="header" href="#lapce">lapce</a></h3>
<p><a href="https://github.com/lapce/lapce"><code>lapce</code></a>是一款性能极高、功能强大、基于<code>wgpu</code>渲染的代码编辑器，基于<code>Xi-Editor</code>开发，后者<code>Xi-Editor</code>曾经也红极一时，可惜不再维护了，但是依然非常适合做一个编辑器内核。</p>
<img alt="lapce screenshot" width="100%" src="./img/superstar/lapce.jpg" class="center"  />
<h3 id="rust-gpu"><a class="header" href="#rust-gpu">rust-gpu</a></h3>
<p><a href="https://github.com/EmbarkStudios/rust-gpu">rust-gpu</a>的目标是让Rust成为GPU编程的第一梯队语言，由大名鼎鼎的<code>Embark</code>公司开发，后台较硬。</p>
<p>如果需要通用的<code>GPU</code>编程，选它就对了。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="命令行工具"><a class="header" href="#命令行工具">命令行工具</a></h2>
<p>对于每一个程序员而言，命令行工具都非常关键。你对他越熟悉，在使用计算机、处理工作流程等越是高效。</p>
<p>下面我们收集了一些优秀的Rust所写的命令行工具，它们相比目前已有的其它语言的实现，可以提供更加现代化的代码实现、更加高效的性能以及更好的可用性。</p>
<h2 id="目录"><a class="header" href="#目录">目录</a></h2>
<table><thead><tr><th>新工具</th><th>替代的目标或功能描述</th></tr></thead><tbody>
<tr><td><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7.html#bat">bat</a></td><td>cat</td></tr>
<tr><td><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7.html#exa">exa</a></td><td>ls</td></tr>
<tr><td><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7.html#lsd">lsd</a></td><td>ls</td></tr>
<tr><td><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7.html#fd">fd</a></td><td>find</td></tr>
<tr><td><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7.html#procs">procs</a></td><td>ps</td></tr>
<tr><td><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7.html#sd">sd</a></td><td>sed</td></tr>
<tr><td><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7.html#dust">dust</a></td><td>du</td></tr>
<tr><td><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7.html#starship">starship</a></td><td>现代化的命令行提示</td></tr>
<tr><td><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7.html#ripgrep">ripgrep</a></td><td>grep</td></tr>
<tr><td><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7.html#tokei">tokei</a></td><td>代码统计工具</td></tr>
<tr><td><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7.html#hyperfine">hyperfine</a></td><td>命令行benchmark工具</td></tr>
<tr><td><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7.html#bottom">bottom</a></td><td>top</td></tr>
<tr><td><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7.html#tealdear">teeldear</a></td><td>tldr</td></tr>
<tr><td><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7.html#grex">grex</a></td><td>根据文本示例生成正则</td></tr>
<tr><td><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7.html#bandwhich">bandwitch</a></td><td>显示进程、连接网络使用情况</td></tr>
<tr><td><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7.html#zoxide">zoxide</a></td><td>cd</td></tr>
<tr><td><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7.html#delta">delta</a></td><td>git可视化</td></tr>
<tr><td><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7.html#nushell">nushell</a></td><td>全新的现代化shell</td></tr>
<tr><td><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7.html#mcfly">mcfly</a></td><td>替代<code>ctrl + R</code>命令搜索</td></tr>
<tr><td><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7.html#fselect">fselect</a></td><td>使用SQL语法查找文件</td></tr>
<tr><td><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7.html#pueue">pueue</a></td><td>命令行任务管理工具</td></tr>
<tr><td><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7.html#watchexec">watchexec</a></td><td>监视目录文件变动并执行命令</td></tr>
<tr><td><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7.html#dura">dura</a></td><td>更加安全的使用git</td></tr>
<tr><td><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7.html#alacritty">alacritty</a></td><td>强大的基于OpenGL的终端</td></tr>
<tr><td><a href="%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7.html#broot">broot</a></td><td>可视化访问目录树</td></tr>
</tbody></table>
<h3 id="bat"><a class="header" href="#bat"><a href="https://github.com/sharkdp/bat">bat</a></a></h3>
<p><code>bat</code>克隆了<strong>cat</strong>的功能并提供了语法高亮和Git集成，它支持<code>Windows</code>，<code>MacOS</code>和<code>Linux</code>。同时，它默认提供了多种文件后缀的语法高亮。</p>
<img alt="bat screenshot" width="100%" src="./img/command-line/bat.png" class="center"  />
<h3 id="exa"><a class="header" href="#exa"><a href="https://github.com/ogham/exa">exa</a></a></h3>
<p><code>exa</code>是<code>ls</code>命令的现代化实现，后者是目前<code>Unix/Linux</code>系统的默认命令，用于列出当前目录中的内容。</p>
<img alt="exa screenshot" width="100%"  src="./img/command-line/exa.jpg" class="center"  />
<h3 id="lsd"><a class="header" href="#lsd"><a href="https://github.com/Peltoche/lsd">lsd</a></a></h3>
<p><code>lsd</code>也是<code>ls</code>的新实现，同时增加了很多特性，例如：颜色标注、icons、树形查看、更多的格式化选项等。</p>
<img alt="lsd screenshot" width="100%"  src="./img/command-line/lsd.png" class="center"  />
<h3 id="fd"><a class="header" href="#fd"><a href="https://github.com/sharkdp/fd">fd</a></a></h3>
<p><code>fd</code>是一个更快、对用户更友好的<strong>find</strong>实现，后者是<code>Unix/Linux</code>内置的文件目录搜索工具。之所以说它用户友好，一方面是<code>API</code>非常清晰明了，其次是它对最常用的场景提供了有意义的默认值：例如，想要通过名称搜索文件：</p>
<ul>
<li><code>fd</code>: <code>fd PATTERN</code></li>
<li><code>find</code>: <code>find -iname 'PATTERN'</code></li>
</ul>
<p>同时<code>fd</code>性能非常非常高，还提供了非常多的搜索选项，例如允许用户通过<code>.gitignore</code>文件忽略隐藏的目录、文件等。</p>
<img alt="fd screenshot" width="100%"  src="./img/command-line/fd.svg" class="center"  />
<h3 id="procs"><a class="header" href="#procs"><a href="https://github.com/dalance/procs">procs</a></a></h3>
<p><code>proc</code>是<strong>ps</strong>的默认实现，后者是<code>Unix/Linux</code>的内置命令，用于获取进程(<code>process</code>)的信息。<code>proc</code>提供了更便利、可读性更好的格式化输出。</p>
<img alt="procs screenshot" width="100%"  src="./img/command-line/procs.jpg" class="center"  />
<h3 id="sd"><a class="header" href="#sd"><a href="https://github.com/chmln/sd">sd</a></a></h3>
<p><code>sd</code>是<strong>sed</strong>命令的现代化实现，后者是<code>Unix/Linux</code>中内置的工具，用于分析和转换文本。</p>
<p><code>sd</code>拥有更简单的使用方式，而且支持方便的正则表达式语法，<code>sd</code>拥有闪电般的性能，比<code>sed</code>快<strong>2x-11x</strong>倍。</p>
<p>以下是其中一个性能测试结果：</p>
<p><em>对1.5G大小的JSON文本进行简单替换</em></p>
<p><code>hyperfine -w 3 'sed -E &quot;s/\&quot;/\'/g&quot; *.json &gt;/dev/null' 'sd &quot;\&quot;&quot; &quot;\'&quot; *.json &gt;/dev/null' --export-markdown out.md</code></p>
<table><thead><tr><th align="left">Command</th><th align="right">Mean [s]</th><th align="right">Min…Max [s]</th></tr></thead><tbody>
<tr><td align="left"><code>sed -E &quot;s/\&quot;/'/g&quot; *.json &gt;/dev/null</code></td><td align="right">2.338 ± 0.008</td><td align="right">2.332…2.358</td></tr>
<tr><td align="left"><code>sed &quot;s/\&quot;/'/g&quot; *.json &gt;/dev/null</code></td><td align="right">2.365 ± 0.009</td><td align="right">2.351…2.378</td></tr>
<tr><td align="left"><code>sd &quot;\&quot;&quot; &quot;'&quot; *.json &gt;/dev/null</code></td><td align="right"><strong>0.997 ± 0.006</strong></td><td align="right">0.987…1.007</td></tr>
</tbody></table>
<p>结果: ~2.35 times faster</p>
<h3 id="dust"><a class="header" href="#dust"><a href="https://github.com/bootandy/dust">dust</a></a></h3>
<p><code>dust</code>是一个更符合使用习惯的<strong>du</strong>，后者是<code>Unix/Linux</code>内置的命令行工具，用于显示硬盘使用情况的统计。</p>
<img alt="dust screenshot" width="100%"  src="./img/command-line/dust.png" class="center"  />
<h3 id="starship-1"><a class="header" href="#starship-1"><a href="https://github.com/starship/starship">starship</a></a></h3>
<p>命令行提示，支持任何<code>shell</code>，包括<code>zsh</code>，简单易用、非常快且拥有极高的可配置性, 同时支持智能提示。</p>
<img alt="starship screenshot" width="100%"  src="https://raw.githubusercontent.com/starship/starship/master/media/demo.gif" class="center"  />
<h3 id="ripgrep-1"><a class="header" href="#ripgrep-1"><a href="https://github.com/BurntSushi/ripgrep">ripgrep</a></a></h3>
<p><code>ripgrep</code>是一个性能极高的现代化<code>grep</code>实现，后者是<code>Unix/Linux</code>下的内置文件搜索工具。该项目是Rust的明星项目，一个是因为性能极其的高，另一个就是源代码质量很高，值得学习, 同时<code>Vscode</code>使用它作为内置的搜索引擎。</p>
<p>从功能来说，除了全面支持<code>grep</code>的功能外，<code>repgre</code>支持使用正则递归搜索指定的文件目录，默认使用<code>.gitignore</code>对指定的文件进行忽略。</p>
<img alt="ripgrep screenshot" width="100%"  src="./img/command-line/ripgrep.png" class="center"  />
<h3 id="tokei"><a class="header" href="#tokei"><a href="https://github.com/XAMPPRocky/tokei">tokei</a></a></h3>
<p><code>tokei</code>可以分门别类的统计目录内的代码行数，速度非常快！</p>
<img alt="tokei screenshot" width="100%"  src="./img/command-line/tokei.png" class="center"  />
<h3 id="hyperfine"><a class="header" href="#hyperfine"><a href="https://github.com/sharkdp/hyperfine">hyperfine</a></a></h3>
<p><code>hyperfine</code>是命令行benchmark工具，它支持在多次运行中提供静态的分析，同时支持任何的<code>shell</code>命令，准确的<code>benchmark</code>进度和当前预估等等高级特性。</p>
<img alt="hyperfine screenshot" width="100%"  src="./img/command-line/hyperfine.gif" class="center"  />
<h3 id="bottom"><a class="header" href="#bottom"><a href="https://github.com/ClementTsang/bottom">bottom</a></a></h3>
<p><code>bottom</code>是一个现代化实现的<code>top</code>，可以跨平台、图形化的显示进程/系统的当前信息。</p>
<img alt="bottom screenshot" width="100%"  src="https://github.com/ClementTsang/bottom/raw/master/assets/demo.gif" class="center"  />
<h3 id="tealdear"><a class="header" href="#tealdear"><a href="https://github.com/dbrgn/tealdeer">tealdear</a></a></h3>
<p><code>tealdear</code>是一个更快实现的<strong>tldr</strong>, 一个用于显示<code>man pages</code>的命令行程序，简单易用、基于例子和社区驱动是主要特性。</p>
<img alt="teeldear screenshot" width="100%"  src="./img/command-line/teeldear.gif" class="center"  />
<h3 id="bandwhich"><a class="header" href="#bandwhich"><a href="https://github.com/imsnif/bandwhich">bandwhich</a></a></h3>
<p><code>banchwhich</code>是一个客户端实用工具，用于显示当前进程、连接、远程IP(hostname)的网络信息。</p>
<img alt="bandwhich screenshot" width="100%"  src="./img/command-line/bandwhich.gif" class="center"  />
<h3 id="grex"><a class="header" href="#grex"><a href="https://github.com/pemistahl/grex">grex</a></a></h3>
<p><code>grex</code>既是一个命令行工具又是一个库，可以根据用户提供的文本示例生成对应的正则表达式，非常强大。</p>
<img alt="grex screenshot" width="100%"  src="./img/command-line/grex.gif" class="center"  />
<h3 id="zoxide"><a class="header" href="#zoxide"><a href="https://github.com/ajeetdsouza/zoxide">zoxide</a></a></h3>
<p><code>zoxide</code>是一个智能化的<code>cd</code>命令，它甚至会记忆你常用的目录。</p>
<img alt="zoxide screenshot" width="100%"  src="./img/command-line/zoxide.webp" class="center"  />
<h3 id="delta"><a class="header" href="#delta"><a href="https://github.com/dandavison/delta">delta</a></a></h3>
<p><code>delta</code>是一个<code>git</code>分页展示工具，支持语法高亮、代码比对、输出<code>grep</code>等。</p>
<img alt="delta screenshot" width="100%"  src="./img/command-line/delta.png" class="center"  />
<h3 id="nushell-1"><a class="header" href="#nushell-1"><a href="https://github.com/nushell/nushell">nushell</a></a></h3>
<p><code>nushell</code>是一个全新的<code>shell</code>，使用<code>Rust</code>实现。它的目标是创建一个现代化的<code>shell</code>：虽然依然基于<code>Unix</code>的哲学，但是更适合现在的时代。例如，你可以使用<code>SQL</code>语法来选择你想要的内容！</p>
<img alt="delta screenshot" width="100%"  src="https://github.com/nushell/nushell/raw/main/images/nushell-autocomplete5.gif" class="center"  />
<h3 id="mcfly"><a class="header" href="#mcfly"><a href="https://github.com/cantino/mcfly">mcfly</a></a></h3>
<p><code>mcfly</code>会替换默认的<code>ctrl-R</code>，用于在终端中搜索历史命令， 它提供了智能提示功能，并且会根据当前目录中最近执行过的上下文命令进行提示。<code>mcfly</code>甚至使用了一个小型的神经网络用于智能提示！</p>
<img alt="mcfly screenshot" width="100%"  src="./img/command-line/mcfly.png" class="center"  />
<h3 id="fselect"><a class="header" href="#fselect"><a href="https://github.com/jhspetersson/fselect">fselect</a></a></h3>
<p><code>fselect</code>允许使用SQL语法来查找系统中的文件。它支持复杂查询、聚合查询、.gitignore忽略文件、通过宽度高度搜索图片、通过hash搜索文件、文件属性查询等等，相当强大！</p>
<pre><code class="language-console"># 复杂查询
fselect &quot;name from /tmp where (name = *.tmp and size = 0) or (name = *.cfg and size &gt; 1000000)&quot;

# 聚合函数
fselect &quot;MIN(size), MAX(size), AVG(size), SUM(size), COUNT(*) from /home/user/Downloads&quot;

# 格式化函数
fselect &quot;LOWER(name), UPPER(name), LENGTH(name), YEAR(modified) from /home/user/Downloads&quot;
</code></pre>
<h3 id="pueue"><a class="header" href="#pueue"><a href="https://github.com/nukesor/pueue">pueue</a></a></h3>
<p><code>pueue</code>是一个命令行任务管理工具，它可以管理你的长时间运行的命令，支持顺序或并行执行。简单来说，它可以管理一个命令队列。</p>
<img alt="pueue screenshot" width="100%"  src="./img/command-line/pueue.gif" class="center"  />
<h3 id="watchexec"><a class="header" href="#watchexec"><a href="https://github.com/watchexec/watchexec">watchexec</a></a></h3>
<p><code>watchexec</code>可以监视指定的目录、文件的改动，并执行你预设的命令，支持多种配置项和操作系统。</p>
<pre><code class="language-console"># 监视当前目录/子目录中的所有js、css、html文件，一旦发生改变，运行`npm run build`命令
$ watchexec -e js,css,html npm run build

# 当前目录/子目录下任何python文件发生改变时，重启`python server.py`
$ watchexec -r -e py -- python server.py
</code></pre>
<h3 id="dura"><a class="header" href="#dura"><a href="https://github.com/tkellogg/dura">dura</a></a></h3>
<p><code>dura</code>运行在后台，监视你的<code>git</code>目录，提交你未提交的更改但是并不会影响<code>HEAD</code>、当前的分支和<code>git</code>索引(staged文件)。</p>
<p>如果你曾经遇到过**&quot;完蛋, 我这几天的工作内容丢了&quot;**的情况，那么就可以尝试下<code>dura</code>，<code>checkout dura brach</code>，然后代码就可以顺利恢复了：）</p>
<p><strong>恢复代码</strong></p>
<ol>
<li>你可以使用<code>dura</code>分支来恢复</li>
</ol>
<pre><code class="language-console">$ echo &quot;dura/$(git rev-parse HEAD)&quot;
</code></pre>
<ol>
<li>也可以手动恢复</li>
</ol>
<pre><code class="language-console"># Or, if you don't trust dura yet, `git stash`
$ git reset HEAD --hard
# get the changes into your working directory
$ git checkout $THE_HASH
# last few commands reset HEAD back to master but with changes uncommitted
$ git checkout -b temp-branch
$ git reset master
$ git checkout master
$ git branch -D temp-branch
</code></pre>
<h2 id="alacritty-1"><a class="header" href="#alacritty-1">alacritty</a></h2>
<p><a href="https://github.com/alacritty/alacritty">alacritty</a>是一个跨平台、基于OpenGL的终端，性能极高的同时还支持丰富的自定义和可扩展性，可以说是非常优秀的现代化终端。</p>
<p>目前已经是<code>beta</code>阶段，可以作为日常工具来使用。</p>
<img alt="alacritty screenshot" width="100%" src="./img/superstar/alacritty.png" class="center"  />
<h2 id="broot"><a class="header" href="#broot">broot</a></h2>
<p><a href="https://github.com/Canop/broot"><code>broot</code></a>允许你可视化的去访问一个目录结构。</p>
<img alt="broot screenshot" width="100%" src="./img/command-line/broot.png" class="center"  /><div style="break-before: page; page-break-before: always;"></div><h1 id="操作系统"><a class="header" href="#操作系统">操作系统</a></h1>
<p>操作系统范畴很大，本章节中精选的内容聚焦在用Rust实现的操作系统以及用Rust写操作系统的教程。</p>
<h2 id="目录-1"><a class="header" href="#目录-1">目录</a></h2>
<table><thead><tr><th>系统</th><th>描述</th></tr></thead><tbody>
<tr><td><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#redox">redox</a></td><td><code>Unix</code>风格的微内核OS</td></tr>
<tr><td><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#tock">tock</a></td><td>嵌入式操作系统</td></tr>
<tr><td><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#theseus">theseus</a></td><td>独特设计的OS</td></tr>
<tr><td><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#writing-an-os-in-rust">writing os in rust</a></td><td>使用Rust开发简单的操作系统</td></tr>
<tr><td><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#rust-raspberrypi-os-tutorials">rust-raspberrypi-OS-tutorials</a></td><td>Rust嵌入式系统开发教程</td></tr>
<tr><td><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#rcore-os">rcore-os</a></td><td>清华大学提供的<code>rcore</code>操作系统教程</td></tr>
<tr><td><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#edu-os">edu-os</a></td><td>亚琛工业大学操作系统课程的配套项目</td></tr>
</tbody></table>
<h3 id="redox-1"><a class="header" href="#redox-1"><a href="https://github.com/redox-os/redox">redox</a></a></h3>
<p><code>Redox</code>是一个<code>Unix</code>风格的微内核操作系统，使用<code>Rust</code>实现。<code>redox</code>的目标是安全、快速、免费、可用，它在内核设计上借鉴了很多优秀的内核，例如：<code>SeL4</code>, <code>MINIX</code>, <code>Plan 9</code>和<code>BSD</code>。</p>
<p>但<code>redox</code>不仅仅是一个内核，它还是一个功能齐全的操作系统，提供了操作系统该有的功能，例如：内存分配器、文件系统、显示管理、核心工具等等。你可以大概认为它是一个<code>GNU</code>或<code>BSD</code>生态，但是是通过一门现代化、内存安全的语言实现的。</p>
<blockquote>
<p>不过据我仔细观察，redox目前的开发进度不是很活跃，不知道发生了什么，未来若有新的发现会在这里进行更新 - Sunface</p>
</blockquote>
<img alt="redox1 screenshot" width="100%" src="./img/os/redox1.jpg" class="center"  />
<img alt="redox2 screenshot" width="100%" src="./img/os/redox2.jpeg" class="center"  />
<h3 id="tock"><a class="header" href="#tock"><a href="https://github.com/tock/tock">tock</a></a></h3>
<p><code>Tock</code>是一个嵌入式操作系统，设计用于在低内存和低功耗的微控制器上运行多个并发的、相互不信任的应用程序，例如它可在<code>Cortex-M</code>和<code>RISC-V</code>平台上运行。</p>
<p><code>Tock</code>使用两个核心机制保护操作系统中不同组件的安全运行：</p>
<ul>
<li>内核和设备驱动全部使用Rust编写，提供了很好安全性的同时，还将内核和设备进行了隔离</li>
<li>使用了内存保护单元技术，让应用之间、应用和内核之间实现了安全隔离</li>
</ul>
<p>具体可通过这本书了解: <a href="https://book.tockos.org/introduction.html">The Tock Book</a>.</p>
<img alt="tock screenshot" width="100%"  src="https://book.tockos.org/imgs/imix.svg" class="center"  />
<h3 id="theseus"><a class="header" href="#theseus"><a href="https://github.com/theseus-os/Theseus">Theseus</a></a></h3>
<p><code>Theseus</code>是从零开始构建的操作系统，完全使用Rust进行开发。它使用了新的操作系统结构、更好的状态管理，以及利用语言内设计原则将操作系统的职责(如资源管理)转移到编译器中。</p>
<p>该OS目前尚处于早期阶段，但是看上去作者很有信心未来可以落地，如果想要了解，可以通过官方提供的<a href="https://theseus-os.github.io/Theseus/book/index.html">在线书籍</a>进行学习。</p>
<h3 id="writing-an-os-in-rust"><a class="header" href="#writing-an-os-in-rust"><a href="https://os.phil-opp.com">Writing an OS in Rust</a></a></h3>
<p>这是非常有名的博客系列，专门讲解如何使用Rust来写一个简单的操作系统，配套源码在<a href="https://github.com/phil-opp/blog_os">这里</a>，目前已经发布了第二版。</p>
<p>以下是<code>async/await</code>的目录截图：
<img alt="writing-os screenshot" width="100%" src="./img/os/writing-os.jpg" class="center"  /></p>
<h3 id="rust-raspberrypi-os-tutorials"><a class="header" href="#rust-raspberrypi-os-tutorials"><a href="https://github.com/rust-embedded/rust-raspberrypi-OS-tutorials">rust-raspberrypi-OS-tutorials</a></a></h3>
<p>学习如何用Rust开发一个嵌入式操作系统，可以运行在树莓派上。这个教程讲得很细，号称手把手教学，而且是从零实现，因此很值得学习。</p>
<img alt="rrot screenshot" width="50%" height="400px" src="./img/os/rrot.jpg" class="center"  />
<img alt="rrot1 screenshot" width="49%" height="400px" src="./img/os/rrot1.gif" class="center"  />
<h3 id="rcore-os"><a class="header" href="#rcore-os"><a href="https://github.com/rcore-os">rcore-os</a></a></h3>
<p>清华大学提供的<code>rcore</code>操作系统，用Rust实现, 与<code>linux</code>相兼容，主要目的目前还是用于教学，因为还有相关的配套教程，非常值得学习。目前支持的功能不完全列表如下：<code>linux</code>兼容的<code>syscall</code>接口、网络协议栈、简单的文件系统、信号系统、异步IO、内核模块化。</p>
<ul>
<li><a href="https://github.com/rcore-os/rCore">内核实现</a></li>
<li><a href="https://github.com/rcore-os/rCore-Tutorial-Book-v3">配套教程</a> </li>
</ul>
<p>以下是在树莓派上运行的图：
<img alt="rcore screenshot" width="100%" src="./img/os/rcore.jpg" class="center"  /></p>
<h3 id="edu-os"><a class="header" href="#edu-os"><a href="https://github.com/RWTH-OS/eduOS-rs">edu-os</a></a></h3>
<p><code>Unix</code>风格的操作系统，用于教学目的，它是亚琛工业大学（RWTH Aachen University)操作系统课程的配套大项目，但是我并没有找到对应的课程资料，根据作者的描述，上面部分的<strong>Writing an OS in Rust</strong>对他有很大的启发。</p>
<img alt="eduos screenshot" width="100%"  src="https://github.com/RWTH-OS/eduOS-rs/raw/master/img/demo.gif?raw=true" class="center"  /><div style="break-before: page; page-break-before: always;"></div><h1 id="游戏"><a class="header" href="#游戏">游戏</a></h1>
<p>我们精心挑选了一些用Rust写得优秀游戏，希望大家喜欢：)</p>
<h2 id="目录-2"><a class="header" href="#目录-2">目录</a></h2>
<table><thead><tr><th>游戏名</th><th>描述</th></tr></thead><tbody>
<tr><td><a href="%E6%B8%B8%E6%88%8F.html#veloren">veloren</a></td><td>多人在线3D PRG游戏</td></tr>
<tr><td><a href="%E6%B8%B8%E6%88%8F.html#citybound">citybound</a></td><td>多人在线城市模拟游戏</td></tr>
<tr><td><a href="%E6%B8%B8%E6%88%8F.html#sandspiel">sandspiel</a></td><td>创意游戏-落沙世界</td></tr>
<tr><td><a href="%E6%B8%B8%E6%88%8F.html#fish-fight">fish fight</a></td><td>多人2D射击策略游戏</td></tr>
<tr><td><a href="%E6%B8%B8%E6%88%8F.html#doukutsu">doukutsu</a></td><td><code>Cave Story</code>重制版</td></tr>
<tr><td><a href="%E6%B8%B8%E6%88%8F.html#rusted-ruins">rusted ruins</a></td><td>开发世界、像素游戏</td></tr>
<tr><td><a href="%E6%B8%B8%E6%88%8F.html#sulis">sulis</a></td><td>回合制策略游戏</td></tr>
<tr><td><a href="%E6%B8%B8%E6%88%8F.html#zemeroth">zemeroth</a></td><td>2D棋盘策略游戏</td></tr>
<tr><td><a href="%E6%B8%B8%E6%88%8F.html#mk48">mk48</a></td><td>2D多人在线海战游戏</td></tr>
<tr><td><a href="%E6%B8%B8%E6%88%8F.html#theta-wave">theta wave</a></td><td>2D太空射击游戏</td></tr>
<tr><td><a href="%E6%B8%B8%E6%88%8F.html#rust-doom">rust doom</a></td><td>模仿<code>Doom</code>的射击游戏</td></tr>
</tbody></table>
<h3 id="veloren"><a class="header" href="#veloren">veloren</a></h3>
<p><a href="https://gitlab.com/veloren/veloren">Veloren</a>是一款多人在线3D RPG游戏，该游戏借鉴了<code>Cube World</code>、<code>Minecraft(我的世界)</code>和<code>Dwarf fortress</code>。</p>
<p>目前游戏开发非常活跃，也是Rust目前游戏中最有前景的之一，值得看好，当前已经可以玩，你可以通过<a href="https://veloren.net/account/">官方地址</a>在线试玩。</p>
<img alt="veloren screenshot" width="100%" src="./img/game/veloren.jpg" class="center"  />
<h3 id="citybound-1"><a class="header" href="#citybound-1">citybound</a></h3>
<p><a href="https://github.com/citybound/citybound">citybound</a>是一个多人在线模拟游戏，使用Rust + WASM + JS开发。</p>
<img alt="citybound screenshot" width="100%" src="./img/game/citybound.png" class="center"  />
<h3 id="sandspiel"><a class="header" href="#sandspiel">sandspiel</a></h3>
<p><a href="https://github.com/MaxBittker/sandspiel">sandspiel</a>是一款很有创意、很艺术的游戏，通过天上落下的沙子来构建美丽的沙世界。该游戏使用Rust + wasm + webgl + js(胶水，用来粘合前几个)构建。</p>
<p>你可以<a href="https://sandspiel.club">在线试玩</a>，尝试构建自己的沙世界。</p>
<img alt="sandspiel screenshot" width="100%" src="./img/game/sandspiel.png" class="center"  />
<h3 id="fish-fight"><a class="header" href="#fish-fight">fish-fight</a></h3>
<p><a href="https://github.com/fishfight/FishFight">Fish Fight</a>是一款2D射击策略游戏，支持最多4人一起玩，可以通过在线的方式或共享屏幕的方式玩，总之这是一款相当不错的游戏，<a href="https://fishfight.org">官网</a>做得也很酷。</p>
<img alt="fish-fight screenshot" width="100%" src="./img/game/fish-fight.jpg" class="center"  />
<h3 id="doukutsu"><a class="header" href="#doukutsu">doukutsu</a></h3>
<p><a href="https://github.com/doukutsu-rs/doukutsu-rs">doukutsu</a>是2004年发行的视频游戏<code>Cave Story</code>的重制版，使用Rust开发。</p>
<p><img alt="doukutsu1 screenshot" width="100%" src="./img/game/doukutsu1.
png" class="center"  />
<img alt="doukutsu2 screenshot" width="100%" src="./img/game/doukutsu2.
png" class="center"  /></p>
<h3 id="rusted-ruins"><a class="header" href="#rusted-ruins">rusted-ruins</a></h3>
<p><a href="https://github.com/garkimasera/rusted-ruins">rusted-ruins</a>是一个开放世界2D像素游戏，用户可以在里面探索各种野外和废墟。</p>
<p>目前游戏还处于较为早期阶段，但是开发活跃。</p>
<p><img alt="rusted-ruins1 screenshot" width="100%" src="./img/game/rusted-ruins1.
png" class="center"  />
<img alt="rusted-ruins2 screenshot" width="100%" src="./img/game/rusted-ruins2.
png" class="center"  /></p>
<h3 id="sulis"><a class="header" href="#sulis">sulis</a></h3>
<p><a href="https://github.com/Grokmoo/sulis">sulis</a>是一款回合制策略游戏，包含了一个从零开发的引擎，目前游戏已经具备相当高的可玩性，你还可以选择不同的势力，感兴趣的同学可以一试。</p>
<img alt="sulis screenshot" width="100%" src="./img/game/sulis.jpg" class="center"  />
<h3 id="zemeroth"><a class="header" href="#zemeroth">zemeroth</a></h3>
<p><a href="https://github.com/ozkriff/zemeroth">zemeroth</a>是一个2D棋盘策略游戏，通过Rust + WASM实现。</p>
<p>你可以通过<a href="https://ozkriff.itch.io/zemeroth">在线网址</a>，使用WASM来体验这个游戏。</p>
<p><img alt="zemeroth1 screenshot" width="100%" src="./img/game/zemeroth1.
png" class="center"  />
<img alt="zemeroth2 screenshot" width="100%" src="./img/game/zemeroth2.
jpeg" class="center"  /></p>
<h3 id="mk48"><a class="header" href="#mk48">mk48</a></h3>
<p><a href="https://github.com/SoftbearStudios/mk48">mk48</a>是一个2D海战游戏，支持多人在线和和多语言(包括中文)，你可以通过官方网址在线试玩: <a href="https://mk48.io">https://mk48.io</a>。</p>
<p><img alt="mk48 screenshot" width="100%" src="./img/game/mk48.
jpg" class="center"  /></p>
<h3 id="theta-wave"><a class="header" href="#theta-wave">theta wave</a></h3>
<p><a href="https://github.com/thetawavegame/thetawave-legacy">Theta Wave</a>是一款2D太空射击游戏，基于<code>Amethyst</code>引擎开发。</p>
<p>在游戏中，你扮演的是保卫目标的飞船，游戏的目标是通过摧毁敌人来存活，还可以收集货币用于购买对你的生存有帮助的物品，并击败最终BOSS取得胜利。</p>
<p><img alt="theta-wave screenshot" width="100%" src="./img/game/theta.
jpg" class="center"  /></p>
<h3 id="rust-doom"><a class="header" href="#rust-doom">rust doom</a></h3>
<p><a href="https://github.com/cristicbz/rust-doom">Rust doom</a>是一款模仿<code>Doom 1&amp;2</code>的简单射击游戏，需要注意，它并不是一个<code>Doom</code>移植版。</p>
<p><img alt="rust-doom screenshot" width="100%" src="./img/game/rust-doom.
jpg" class="center"  /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="游戏开发"><a class="header" href="#游戏开发">游戏开发</a></h1>
<p>我在这里大胆预言：Rust未来会成为和<code>C++</code>同级别的游戏开发语言，特别是在游戏引擎方面，会大放异彩。</p>
<h2 id="索引"><a class="header" href="#索引">索引</a></h2>
<ul>
<li><a href="%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91.html#%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E"><strong>游戏引擎</strong></a>： <a href="%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91.html#bevy">bevy</a>， <a href="%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91.html#fyrox%E5%89%8Drg3d">fyrox</a>， <a href="%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91.html#ggez">ggez</a>， <a href="%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91.html#oxygengine">oxygengine</a>， <a href="%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91.html#macroquad">macroquad</a>， <a href="%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91.html#godot-rust">godot-rust</a>， <a href="%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91.html#piston">piston</a>， <a href="%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91.html#amethyst">amethyst</a></li>
<li><a href="%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91.html#gpu%E5%92%8C%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93"><strong>GPU和图形渲染</strong></a>： <a href="%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91.html#wgpu">wgpu</a>， <a href="%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91.html#rust-gpu">rust-gpu</a>，<a href="%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91.html#kajiya">kajiya</a>， <a href="%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91.html#lyon">lyon</a>， <a href="%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91.html#ash">ash</a>， <a href="%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91.html#vulkano">vulkano</a>， <a href="%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91.html#rend3">rend3</a>， <a href="%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91.html#rafx">rafx</a>， <a href="%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91.html#gfx">gfx</a>， <a href="%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91.html#luminance">luminance</a>， <a href="%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91.html#miniquad">miniquad</a>， <a href="%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91.html#glow">glow</a></li>
<li><a href="%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91.html#%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99"><strong>学习资料和新闻</strong></a></li>
</ul>
<h2 id="游戏引擎"><a class="header" href="#游戏引擎">游戏引擎</a></h2>
<h3 id="bevy-1"><a class="header" href="#bevy-1">Bevy</a></h3>
<p><a href="https://github.com/bevyengine/bevy">bevy</a>是一个数据驱动的游戏引擎，支持2D和3D图形开发，优点是社区活跃、更新快、模块化设计优秀、性能高，缺点是还处于快速开发中，并不适合生产使用。</p>
<p>同时<code>bevy</code>的文档齐全，官方示例很多，非常适合学习和使用。</p>
<img alt="fyrox screenshot" width="100%" src="./img/gamedev/bevy.jpg" class="center"  />
<h3 id="fyrox前rg3d"><a class="header" href="#fyrox前rg3d">Fyrox(前rg3d)</a></h3>
<p><a href="https://github.com/FyroxEngine/Fyrox">fyrox</a>是一个<code>2D</code>和<code>3D</code>游戏图形化引擎，功能丰富，生产可用(官方宣称)。</p>
<p>该项目前身是<code>rg3d</code>，但是被收购后，更名为<code>fyrox</code>，潜力应该是相当好的，下面截图来源于基于该引擎开发的游戏<a href="https://github.com/mrDIMAS/StationIapetus"><code>StationIapetus</code></a>。</p>
<img alt="fyrox screenshot" width="100%" src="./img/gamedev/fyrox.jpg" class="center"  />
<h3 id="ggez"><a class="header" href="#ggez">ggez</a></h3>
<p><a href="https://github.com/ggez/ggez">ggez</a>是一个轻量级的<code>2D</code>游戏图形引擎，它的目标是让游戏开发尽量的简单，因此它的功能并不是很强大，例如如果你想要强大且真实的物理引擎，它可能无能为力，但你可以选择在它的基础上构建自己的更高级的引擎。</p>
<img alt="ggez screenshot" width="100%" src="./img/gamedev/ggez.png" class="center"  />
<h3 id="oxygengine"><a class="header" href="#oxygengine">oxygengine</a></h3>
<p><a href="https://github.com/PsichiX/oxygengine">oxygengine</a>是一个<code>2D</code> HTML5游戏引擎，支持编译成WASM在浏览器中运行。</p>
<img alt="oxygengine screenshot" width="100%" src="./img/gamedev/oxygengine.gif" class="center"  />
<h3 id="macroquad"><a class="header" href="#macroquad">macroquad</a></h3>
<p><a href="https://github.com/not-fl3/macroquad">macroquad</a>是一个<code>2D</code>游戏引擎，特点是简单易用，例如它试图让使用者不会遇到Rust生命周期的难题。</p>
<h3 id="godot-rust"><a class="header" href="#godot-rust">godot-rust</a></h3>
<p><a href="https://github.com/godot-rust/godot-rust">godot-rust</a>是大名鼎鼎的<code>godot</code>引擎的<code>Rust</code>绑定，<a href="https://github.com/godotengine/godot"><code>godot</code></a>是<code>c++</code>开发的游戏<code>2D/3D</code>引擎，但是对Rust语言提供了很好的支持。</p>
<img alt="godot screenshot" width="100%" src="./img/gamedev/godot.jpg" class="center"  />
<h3 id="piston"><a class="header" href="#piston">piston</a></h3>
<p><a href="https://github.com/PistonDevelopers/piston">piston</a>是前两年较火的模块化的游戏引擎，但是最近半年开发速度缓慢，我调查了一番，但不清楚发生了什么。</p>
<h3 id="amethyst"><a class="header" href="#amethyst">Amethyst</a></h3>
<p><a href="https://github.com/amethyst/amethyst">Amethyst</a>, 前几年较火的Rust游戏引擎，但是最近开发已经停滞，经过我调查，是因为作者团队转型Rust游戏开发知识分享，因此项目被<a href="https://amethyst.rs/posts/amethyst--starting-fresh">放弃</a>。</p>
<h2 id="gpu和图形渲染"><a class="header" href="#gpu和图形渲染">GPU和图形渲染</a></h2>
<h3 id="wgpu"><a class="header" href="#wgpu">wgpu</a></h3>
<p><a href="https://github.com/gfx-rs/wgpu">wgpu</a>是一个纯Rust实现的图形化API库，具有安全、可移植等优点，如果你使用基于<code>wgpu</code>构建的库，那该库可以很多平台上运行：Linux, windows, MacOS, Android和IOS。</p>
<p>它可以原生的运行在<code>Vulkan</code>, <code>Metal</code>等主流平台上，且可以使用<code>wasm</code>的方式运行在<code>WebGPU</code>上，同时API兼容<code>WebGPU</code>标准。</p>
<p>总之，如果你要使用<code>WebGPU</code>, 选它就对了。</p>
<h3 id="rust-gpu-1"><a class="header" href="#rust-gpu-1">rust-gpu</a></h3>
<p><a href="https://github.com/EmbarkStudios/rust-gpu">rust-gpu</a>的目标是让Rust成为GPU编程的第一梯队语言，由大名鼎鼎的<code>Embark</code>公司开发，后台较硬。</p>
<p>如果需要通用的<code>GPU</code>编程，选它就对了。</p>
<h3 id="kajiya"><a class="header" href="#kajiya">kajiya</a></h3>
<p><a href="https://github.com/EmbarkStudios/kajiya">kajiya</a>是一个实时的、全局光照渲染系统，由<code>Embark</code>公司开发，该公司在秘密研究急于Rust的游戏引擎，据说准备应用在新游戏上，有朝一日它可能会是推动Rust游戏引擎爆发式发展的功臣。</p>
<p><code>kajiya</code>应用了非常先进的论文和设计理念，因此非常值得有志于游戏引擎开发的同学学习。但目前还不适用于生产级使用，具体见<a href="https://medium.com/embarkstudios/homegrown-rendering-with-rust-1e39068e56a7">这里</a>。</p>
<img alt="kajiya screenshot" width="100%" src="./img/gamedev/kajiya.jpg" class="center"  />
<h3 id="lyon"><a class="header" href="#lyon">lyon</a></h3>
<p><a href="https://github.com/nical/lyon">lyon</a>可以使用GPU进行向量路径渲染，例如高效渲染复杂的<code>svg</code>等。</p>
<h3 id="ash"><a class="header" href="#ash">ash</a></h3>
<p><a href="https://github.com/MaikKlein/ash">ash</a>是一个轻量级的<code>Vulkan</code>绑定。</p>
<img alt="ash screenshot" width="100%" src="./img/gamedev/ash.png" class="center"  />
<h3 id="vulkano"><a class="header" href="#vulkano">vulkano</a></h3>
<p><a href="https://github.com/vulkano-rs/vulkano">vulkano</a>是一个安全、特性丰富的<code>Vulkan</code>绑定。</p>
<h3 id="rend3"><a class="header" href="#rend3">rend3</a></h3>
<p><a href="https://github.com/BVE-Reborn/rend3">rend3</a>是一个简单易用、可定制性强、高效的3D渲染库，基于<code>wgpu</code>开发。</p>
<img alt="rend3 screenshot" width="100%" src="./img/gamedev/rend3.jpg" class="center"  />
<h3 id="rafx"><a class="header" href="#rafx">rafx</a></h3>
<p><a href="https://github.com/aclysma/rafx">rafx</a>是一个多后端渲染器，目标是性能、扩展性和生产力。</p>
<img alt="rafx screenshot" width="100%" src="./img/gamedev/rafx.jpg" class="center"  />
<h3 id="gfx"><a class="header" href="#gfx">gfx</a></h3>
<p><a href="https://github.com/gfx-rs/gfx">gfx</a>是一个底层的图形库，目前已经不怎么活跃，主要原因是：它的核心组件<code>gfx-hal</code>最开始的目标是为<code>wgpu</code>提供功能，但是后面<code>wgpu</code>实现了自己的<code>wgpu-hal</code>，因此<code>gfx-hal</code>目前仅处于维护状态。</p>
<h3 id="luminance"><a class="header" href="#luminance">luminance</a></h3>
<p><a href="https://github.com/phaazon/luminance-rs">luminance</a>是一个类型安全、无状态的图形框架，目标是让图形渲染变得简单和优雅，最开始是通过<code>Haskell</code>语言实现，然后在<code>2016</code>年移植到<code>Rust</code>上。</p>
<p>它很简单，功能也不够强大，如果你没有<code>OpenGL</code>、<code>Vulkan</code>的经验，可以使用它做一些简单的图形渲染项目试试。</p>
<h3 id="miniquad"><a class="header" href="#miniquad">miniquad</a></h3>
<p><a href="https://github.com/not-fl3/miniquad">miniquad</a>是一个安全和跨平台的图形渲染库，它提供了较为底层的API，如果需要抽象层次更高的API，可以使用之前提到的<a href="https://github.com/not-fl3/macroquad">macroquad</a>,后者是基于<code>miniquad</code>封装实现。</p>
<img alt="miniquad screenshot" width="100%" src="./img/gamedev/miniquad.gif" class="center"  />
<h3 id="glow"><a class="header" href="#glow">glow</a></h3>
<p><a href="https://github.com/grovesNL/glow">glow</a>提供了各种<code>GL</code>绑定(OpenGL, WebGL), 提供了一定的抽象，避免你写平台相关的特定代码实现。</p>
<h2 id="学习资料"><a class="header" href="#学习资料">学习资料</a></h2>
<h3 id="游戏开发最新新闻"><a class="header" href="#游戏开发最新新闻">游戏开发最新新闻</a></h3>
<ul>
<li><a href="https://gamedev.rs">gamedev</a></li>
</ul>
<h3 id="一些学习资料英文"><a class="header" href="#一些学习资料英文">一些学习资料(英文)</a></h3>
<ul>
<li><a href="https://pragprog.com/titles/hwrust/hands-on-rust/">Hands-on Rust</a></li>
<li>使用<a href="https://github.com/amethyst/bracket-lib">bracket-lib</a>和其<a href="https://bfnightly.bracketproductions.com/rustbook/">配套书籍</a>进行学习</li>
<li>想要没有困难的开发一个跨平台的2D游戏？使用<a href="https://macroquad.rs"><code>macroquad</code></a>，并且可以参考用它开发的两个游戏: <a href="https://github.com/fishfight/FishFight">fish fight</a>和<a href="https://github.com/ozkriff/zemeroth">zemeroth</a></li>
<li>想要开发一个简单的3D游戏并且需要一个编辑器？可以试试<a href="https://github.com/rg3dengine/rg3d"><code>fyrox(rg3d)</code></a></li>
<li>想要开发一个复杂的游戏或者想要做一个demo，未来可以基于该demo继续开发，最终完成一个复杂游戏？可以试试<code>godot</code>引擎提供的<code>Rust</code>绑定：<a href="https://godot-rust.github.io">godot-rust</a></li>
<li>喜欢钻研前沿技术？试试<a href="https://bevyengine.org"><code>bevy</code></a>，它拥有最好的<code>ECS</code>实现和最先进的设计理念(可能)</li>
</ul>
<h3 id="ecsentity-component-system和dod面向数据设计资料"><a class="header" href="#ecsentity-component-system和dod面向数据设计资料">ECS(Entity Component System)和DOD(面向数据设计)资料</a></h3>
<p>我们在上面提到的很多系统都使用了<code>ECS</code>和<code>DOD</code>，因此这两者对于游戏开发是极其重要的，下面是一些相关的英文资料(部分需要翻墙)，可以帮助大家理解相关概念。</p>
<ul>
<li><a href="https://github.com/Ralith/hecs">hecs</a>, 一个用Rust实现的ECS世界</li>
<li><a href="https://www.youtube.com/watch?v=0_Byw9UMn9g">Understanding data-oriented design for entity component systems - Unity at GDC 2019</a></li>
<li><a href="https://www.youtube.com/watch?v=yy8jQgmhbAU">CppCon 2018: Stoyan Nikolov “OOP Is Dead, Long Live Data-oriented Design”</a></li>
<li><a href="https://www.youtube.com/watch?v=aKLntZcp27M">RustConf 2018 - Closing Keynote - Using Rust For Game Development by Catherine West</a></li>
<li><a href="https://dataorienteddesign.com/dodbook/">&quot;Data-Oriented Design&quot; web book by Richard Fabian</a></li>
</ul>
<h3 id="一些游戏开发的生产力工具"><a class="header" href="#一些游戏开发的生产力工具">一些游戏开发的生产力工具</a></h3>
<ul>
<li><a href="https://www.blender.org">Blender</a>用于3D建模</li>
<li><a href="https://krita.org/en">Krita</a>用于创建2D图片</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用rust增强javascript"><a class="header" href="#使用rust增强javascript">使用Rust增强Javascript</a></h1>
<p><code>Javascript</code>是目前全世界使用最广的语言(TIOBE排行榜比较迷，JS并没有排在第一位，我个人并不认同它的排名)。在过去这么多年中，围绕着<code>Javascript</code>已经建立了庞大的基础设施生态：例如使用<code>webpack</code>来将多个<code>js</code>文件打包成一个；使用<code>Babel</code>允许你用现代化的<code>js</code>语法编写兼容旧浏览器的代码；使用<code>Eslint</code>帮助开发找出代码中潜在的问题，类似<code>cargo clippy</code>。</p>
<p>以上的种种都在帮助<code>js</code>成为更好的语言和工具，它们是<code>Web</code>应用程序得以顺利、高效的开发和运行的基石。这些工具往往使用<code>Javascript</code>语言编写，一般来说，是没有问题的，但是在某些时候，可能会存在性能上的瓶颈或者安全隐患，因此阴差阳错、机缘巧合下，<code>Rust</code>成为了一个搅局者。</p>
<h2 id="javascript基建库"><a class="header" href="#javascript基建库">Javascript基建库</a></h2>
<h3 id="deno-1"><a class="header" href="#deno-1">deno</a></h3>
<p>首先出场的自然是咖位最重的之一，可以说正是因为<code>deno</code>和<code>swc</code>的横空出世，才让一堆观望的大神对于Rust实现<code>Javascript</code>基建有了更强的信心。</p>
<p><code>deno</code>是<code>node</code>半逆转后的字序，从此可以看出<code>deno</code>是<code>Node.js</code>的替代，它的目标是为<code>Typescript/Javascript</code>提供一个更现代化、更安全、更强大    的运行时，同时内置了很多强大的工具，可以用于打包、编译成可执行文件、文档、测试、lint等。</p>
<p>值得一提的是，<code>deno</code>的不少工具都使用了<code>swc</code>进行建造，包括代码审查、格式化、文档生成等。</p>
<p>通过包引入的方式来对比下<code>deno</code>和<code>node</code>，大家可以自己品味下。</p>
<pre><code class="language-js">// node
const koa = require(&quot;koa&quot; );
cost logger = require(&quot;@adesso/logger&quot;)

// deno
import { Application } from &quot;https://deno.land/x/oak/mod.ts&quot;;
import { Logger } from &quot;https://adesso.de/lib/logger.ts&quot;
</code></pre>
<h3 id="swc"><a class="header" href="#swc">swc</a></h3>
<p><a href="https://github.com/swc-project/swc"><code>swc</code></a>是<code>Typescript/Javascript</code>编译器，它可以用来编译、压缩和打包JS，同时支持使用插件进行扩展，例如做代码变换等。</p>
<p><code>swc</code>目前正在被一些知名项目所使用，包括<code>Next.js</code>,<code>Parcel</code>和<code>Deno</code>，还有些著名的公司也在使用它，例如<code>Vercel</code>、字节跳动、腾讯等。</p>
<p>它的性能非常非常高，官方号称，在单线程下比<code>Babel</code>快20倍，在4核心下比<code>Babel</code>快70倍！</p>
<p>几个使用案例：</p>
<ul>
<li><a href="http://nextjs.org/12">nextjs 12</a>, 通过使用<code>swc</code>获得了更好的扩展性、性能以及wasm的支持，其中性能方面提升了3倍刷新速度、5倍打包速度</li>
<li><a href="https://parceljs.org/">Parcel</a>，通过使用<code>swc</code>改善了10倍的性能</li>
</ul>
<img alt="parcel screenshot" width="100%" src="./img/javascript/parcel.png" class="center"  />
<p>官方还提供了一个在线运行的<a href="https://swc.rs/playground">demo</a>，功能齐全，可以试试。</p>
<img alt="swc screenshot" width="100%" src="./img/javascript/swc.jpg" class="center"  />
<h3 id="rome"><a class="header" href="#rome">Rome</a></h3>
<p><a href="https://github.com/rome/tools"><code>Rome</code></a>可以用来对<code>JavaScript</code>、<code>TypeScript</code>、<code>HTML</code>、<code>JSON</code>、<code>Markdown</code> 和 <code>CSS</code> 进行lint、编译、打包等功能，它的目标是替代<code>Babel</code>、<code>ESLint</code>、<code>webpack</code>、<code>Prettier</code>、<code>Jest</code>等。</p>
<p>一开始<code>Rome</code>是使用<code>Typescript</code>开发，目前正在用<code>Rust</code>进行重写。有趣的是: <code>Rome</code>的作者也是<code>Babel</code>的作者, 后者还是他在学习编译原理时做的。</p>
<h3 id="fnm"><a class="header" href="#fnm">fnm</a></h3>
<p><a href="https://github.com/Schniz/fnm"><code>fnm</code></a>是一个简单易用、高性能的<code>Node</code>版本管理工具，还支持<code>.nvmrc</code>文件(<code>nvm</code>的<code>node</code>版本描述文件)</p>
<img alt="fnm screenshot" width="100%" src="./img/javascript/fnm.svg" class="center"  />
<h3 id="boa"><a class="header" href="#boa">boa</a></h3>
<p><a href="https://github.com/boa-dev/boa"><code>boa</code></a>是一个高性能的<code>javascript</code>词法分析器，解析器和解释器，目前还是实验性质的。</p>
<img alt="boa screenshot" width="100%" src="./img/javascript/boa.gif" class="center"  />
<h3 id="napi"><a class="header" href="#napi">napi</a></h3>
<p><a href="https://github.com/napi-rs/napi-rs"><code>napi</code></a>可以用于构建基于<code>Node API</code>的<code>Nodejs</code>插件，目前由<code>nextjs</code>主导开发。</p>
<h3 id="volt"><a class="header" href="#volt">volt</a></h3>
<p><a href="https://github.com/voltpkg/volt"><code>volt</code></a>是一个现代化的、高性能、安全可靠的<code>Javascript</code>包管理工具。目前该库正处于活跃开发阶段，只供学习使用。</p>
<img alt="volt screenshot" width="100%" src="./img/javascript/volt.png" class="center"  />
<h3 id="neon"><a class="header" href="#neon">neon</a></h3>
<p><a href="https://github.com/neon-bindings/neon"><code>neon</code></a>可以用于写安全、高性能的原生<code>Nodejs</code>模块。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn make_an_array(mut cx: FunctionContext) -&gt; JsResult&lt;JsArray&gt; {
    // 创建一些值:
    let n = cx.number(9000);
    let s = cx.string(&quot;hello&quot;);
    let b = cx.boolean(true);

    // 创建一个新数组:
    let array: Handle&lt;JsArray&gt; = cx.empty_array();

    // 将值推入数组中
    array.set(&amp;mut cx, 0, n)?;
    array.set(&amp;mut cx, 1, s)?;
    array.set(&amp;mut cx, 2, b)?;

    // 返回数组
    Ok(array)
}

register_module!(mut cx, {
    cx.export_function(&quot;makeAnArray&quot;, make_an_array)
})
<span class="boring">}
</span></code></pre></pre>
<h3 id="resvg-js"><a class="header" href="#resvg-js">resvg-js</a></h3>
<p><a href="https://github.com/yisibl/resvg-js">resvg-js</a>是一个高性能<code>svg</code>渲染库，使用Rust + Typescript实现。下面的图片通过<code>svg</code>实现(羞～～～): </p>
<img alt="resvg screenshot" width="100%" src="./img/javascript/resvg.svg" class="center"  />
<h3 id="deno_lint"><a class="header" href="#deno_lint">deno_lint</a></h3>
<p><a href="https://github.com/denoland/deno_lint">deno_lint</a>, 由<code>deno</code>团队出品的<code>lint</code>工具，支持<code>Javascript/Typescript</code>，支持<code>Deno</code>也支持<code>Node</code>。</p>
<p>优点之一就是极致的快:</p>
<pre><code class="language-shell">[
  {
    &quot;name&quot;: &quot;deno_lint&quot;,
    &quot;totalMs&quot;: 105.3750100000002,
    &quot;runsCount&quot;: 5,
    &quot;measuredRunsAvgMs&quot;: 21.07500200000004,
    &quot;measuredRunsMs&quot;: [
      24.79783199999997,
      19.563640000000078,
      20.759051999999883,
    ]
  },
  {
    &quot;name&quot;: &quot;eslint&quot;,
    &quot;totalMs&quot;: 11845.073306000002,
    &quot;runsCount&quot;: 5,
    &quot;measuredRunsAvgMs&quot;: 2369.0146612000003,
    &quot;measuredRunsMs&quot;: [
      2686.1039550000005,
      2281.501061,
      2298.6185210000003,
    ]
  }
]
</code></pre>
<h3 id="rslint"><a class="header" href="#rslint">rslint</a></h3>
<p><a href="https://github.com/rslint/rslint">rslint</a>是一个高性能、可定制性强、简单易用的<code>Javascript/Typescript</code> lint分析工具。</p>
<pre><code class="language-shell">$ echo &quot;let a = foo.hasOwnProperty('bar');&quot; &gt; foo.js
$ rslint ./foo.js
error[no-prototype-builtins]: do not access the object property `hasOwnProperty` directly from `foo`
  ┌─ ./foo.js:1:9
  │
1 │ let a = foo.hasOwnProperty('bar');
  │         ^^^^^^^^^^^^^^^^^^^^^^^^^
  │
help: get the function from the prototype of `Object` and call it
  │
1 │ let a = Object.prototype.hasOwnProperty.call(foo, 'bar');
  │         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  │
  ╧ note: the method may be shadowed and cause random bugs and denial of service vulnerabilities

Outcome: 1 fail, 0 warn, 0 success

help: for more information about the errors try the explain command: `rslint explain &lt;rules&gt;`
</code></pre>
<h3 id="rusty_v8"><a class="header" href="#rusty_v8">rusty_v8</a></h3>
<p><a href="https://github.com/denoland/rusty_v8">rusty_v8</a>是<code>v8</code>的Rust语言绑定，底层封装了<code>c++ API</code>。</p>
<h2 id="用wasm增强js"><a class="header" href="#用wasm增强js">用WASM增强JS</a></h2>
<h3 id="wasm"><a class="header" href="#wasm">wasm</a></h3>
<p><a href="https://webassembly.org/docs/use-cases/">wasm(web assembly)</a>是一种低级语言，它运行在浏览器中，可以和<code>javascript</code>相互调用，几乎所有浏览器都支持， 而且目前有多种高级语言都可以直接编译成<code>wasm</code>，更是大大增强了它的地位。</p>
<p>目前来说Rust可以编译成<code>wasm</code>，虽然还不够完美，但是它正在以肉眼可见的速度快速发展中。因此同时使用<code>Rust</code>和<code>Javascript</code>成为了一种可能：将<code>Rust</code>编译成<code>wasm</code>，再跟<code>js</code>进行交互，两者共生共存，各自解决擅长的场景(<code>wasm</code>性能高，<code>js</code>开发速度快)。</p>
<h3 id="yew-1"><a class="header" href="#yew-1">yew</a></h3>
<p><a href="https://github.com/yewstack/yew"><code>yew</code></a>是一个正在活跃开发的<code>Rust/Wasm</code>框架，用于构建<code>Web</code>客户端应用。</p>
<img alt="yew screenshot" width="100%" src="./img/javascript/yew.jpg" class="center"  />
<h3 id="gloo"><a class="header" href="#gloo">gloo</a></h3>
<p>[gloo]是一个模块化的工具，使用<code>Rust/WASM</code>构建快速、可靠的<code>Web</code>应用。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use gloo::{events::EventListener, timers::callback::Timeout};
use wasm_bindgen::prelude::*;

pub struct DelayedHelloButton {
    button: web_sys::Element,
    on_click: events::EventListener,
}

impl DelayedHelloButton {
    pub fn new(document: &amp;web_sys::Document) -&gt; Result&lt;DelayedHelloButton, JsValue&gt; {
        // 创建 `&lt;button&gt;` 元素.
        let button = document.create_element(&quot;button&quot;)?;

        // 监听button上的`click`事件
        let button2 = button.clone();
        let on_click = EventListener::new(&amp;button, &quot;click&quot;, move |_event| {
            // 一秒后，更新button中的文本
            let button3 = button2.clone();
            Timeout::new(1_000, move || {
                button3.set_text_content(Some(&quot;Hello from one second ago!&quot;));
            })
            .forget();
        });

        Ok(DelayedHelloButton { button, on_click })
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="wasm-bindgen"><a class="header" href="#wasm-bindgen">wasm-bindgen</a></h3>
<p><a href="https://github.com/rustwasm/wasm-bindgen">wasm-bindgen</a>可以让<code>WASM</code>模块和<code>Javascript</code>模块进行更好的交互。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasm_bindgen::prelude::*;

// 从Web导入 `window.alert` 函数
#[wasm_bindgen]
extern &quot;C&quot; {
    fn alert(s: &amp;str);
}

// 从Rust导出一个`greet`函数到Javascript，该函数会`alert`一条欢迎信息
#[wasm_bindgen]
pub fn greet(name: &amp;str) {
    alert(&amp;format!(&quot;Hello, {}!&quot;, name));
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="wasm-pack"><a class="header" href="#wasm-pack">wasm-pack</a></h3>
<p><a href="https://github.com/rustwasm/wasm-pack">wasm-pack</a>是一站式的解决方案，用于构建和使用Rust生成的WASM，支持在浏览器中或后台的<code>Node.js</code>中与<code>Javascript</code>进行交互。</p>
<img alt="wasm-pack screenshot" width="100%" src="./img/javascript/wasm-pack.gif" class="center"  />
<h3 id="wasmer-1"><a class="header" href="#wasmer-1">wasmer</a></h3>
<p><a href="https://github.com/wasmerio/wasmer">wasmer</a>是业界领先的<code>WASM</code>运行时，支持<code>WASI</code>和<code>Emscripten</code>。</p>
<pre><code class="language-shell">$ wasmer qjs.wasm
QuickJS - Type &quot;\h&quot; for help
qjs &gt; const i = 1 + 2;
qjs &gt; console.log(&quot;hello &quot; + i);
hello 3
</code></pre>
<h3 id="wasmtime-1"><a class="header" href="#wasmtime-1">wasmtime</a></h3>
<p><a href="https://github.com/bytecodealliance/wasmtime">wasmtime</a>是一个为<code>WASM</code>设计的<code>JIT</code>风格的独立运行时。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<pre><code class="language-shell">$ rustup target add wasm32-wasi
$ rustc hello.rs --target wasm32-wasi
$ wasmtime hello.wasm
Hello, world!
</code></pre>
<h3 id="trunk"><a class="header" href="#trunk">trunk</a></h3>
<p><a href="https://github.com/thedodd/trunk">trunk</a>是一个<code>WASM</code>构建、打包、Web发布工具。</p>
<h3 id="photon"><a class="header" href="#photon">photon</a></h3>
<p><a href="">photon</a>是高性能的、跨平台的图片处理库，使用<code>Rust</code>开发，编译成<code>WASM</code>运行，为你的Web应用和<code>Node.js</code>应用提供无与伦比的图片处理速度，当然，它既然使用<code>Rust</code>开发，也可以作为一个库被你的后台程序所使用。</p>
<img alt="photon screenshot" width="100%" src="./img/javascript/photon.gif" class="center"  />
<h3 id="tinysearch"><a class="header" href="#tinysearch">tinysearch</a></h3>
<p><a href="https://github.com/tinysearch/tinysearch">tinysearch</a>是一个搜索工具，用于静态网站中的内容搜索，使用<code>Rust</code>和<code>WASM</code>构建。优点是体积小(适用于浏览器)、性能高、全文索引。</p>
<img alt="tinysearch screenshot" width="80%" src="./img/javascript/tinysearch.gif" class="center"  />
<h3 id="wasm-pdf"><a class="header" href="#wasm-pdf">wasm-pdf</a></h3>
<p><a href="https://github.com/jussiniinikoski/wasm-pdf">wasm-pdf</a>通过<code>Javascript</code>和<code>WASM</code>来生成<code>PDF</code>，可以直接在浏览器中使用。</p>
<h3 id="makepad"><a class="header" href="#makepad">makepad</a></h3>
<p><a href="https://github.com/makepad/makepad">makepad</a>是一个充满创意的Rust开发平台，支持编译成<code>wasm</code>，并使用<code>webGL</code>进行渲染。</p>
<img alt="makepad screenshot" width="80%" src="./img/javascript/makepad.jpg" class="center"  />
<h2 id="rust--javascript学习教程"><a class="header" href="#rust--javascript学习教程">Rust + Javascript学习教程</a></h2>
<h3 id="wasm-book"><a class="header" href="#wasm-book">wasm-book</a></h3>
<p><a href="https://github.com/rustwasm/book">wasm-book</a>是一本讲述<code>Rust</code>和<code>wasm</code>的书，篇幅不算长，但是值得学习，还包含了几个很酷的例子。</p>
<h3 id="wasm-learning"><a class="header" href="#wasm-learning">wasm-learning</a></h3>
<p><a href="https://github.com/second-state/wasm-learning"><code>wasm-learning</code></a>是一个英文教程，用于学习<code>Rust</code>, <code>wasm</code>和<code>Node.js</code>，你可以学会如何使用<code>Rust</code>来为<code>Nodejs</code>构建函数，可以同时利用<code>Rust</code>的性能、<code>wasm</code>的安全性和可移植性、<code>js</code>的易用性。</p>
<h3 id="rust-js-snake-game"><a class="header" href="#rust-js-snake-game">rust-js-snake-game</a></h3>
<p><a href="https://github.com/RodionChachura/rust-js-snake-game"><code>rust-js-snake-game</code></a>是一个用<code>rust + js + wasm</code>构建的贪食蛇游戏。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gui"><a class="header" href="#gui">GUI</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="assets/ferris.js"></script>

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
